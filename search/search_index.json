{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"isobar isobar is a Python library for creating and manipulating musical patterns, designed for use in algorithmic composition, generative music and sonification. It makes it quick and easy to express complex musical ideas, and can send and receive events from various different sources: MIDI, OSC, SocketIO, and .mid files. What isobar does The core objective of isobar is to provide a framework for sequencing and triggering events, which may be MIDI messages, OSC triggers, triggers for third-party DSP engines such as SuperCollider, or even Python functions. ( What types of event are supported? ) It can be used to trigger events in real time, or to generate patterns that can be serialised as MIDI files and loaded into a DAW. It can sync to external clocks, or act as a clock source to external devices. It can also load patterns serialised in MIDI files for processing. What isobar doesn't do isobar does not generate any audio on its own. It must be configured to send events to an output device which is responsible for sound synthesis. Basic concepts There are a few key components in isobar. The Timeline handles timing and scheduling, triggering events at the correct moment. It can maintain its own clock with millisecond accuracy, or sync to an external clock. Events correspond to triggers that are typically sent to output devices or received from input devices. These may be MIDI notes, control changes, OSC triggers, and other general types. An event is typically described by a dict with a number of properties. For example: { \"note\" : 60, \"amplitude\": 127 } Patterns : Each of the elements of an event can be specified by a Pattern, which generates a sequence of return values. Simple pattern types generate fixed sequences, random values, or values based on statistical models. Patterns can be passed other patterns as parameters, so they can operate on each other -- for example, causing an input pattern to loop N times, or skipping the input values with some probability. Devices : Events are sent to output devices, over interfaces such as MIDI or OSC. Events can also be received and processed. Documentation Getting started Code examples Pattern library reference","title":"Home"},{"location":"#isobar","text":"isobar is a Python library for creating and manipulating musical patterns, designed for use in algorithmic composition, generative music and sonification. It makes it quick and easy to express complex musical ideas, and can send and receive events from various different sources: MIDI, OSC, SocketIO, and .mid files.","title":"isobar"},{"location":"#what-isobar-does","text":"The core objective of isobar is to provide a framework for sequencing and triggering events, which may be MIDI messages, OSC triggers, triggers for third-party DSP engines such as SuperCollider, or even Python functions. ( What types of event are supported? ) It can be used to trigger events in real time, or to generate patterns that can be serialised as MIDI files and loaded into a DAW. It can sync to external clocks, or act as a clock source to external devices. It can also load patterns serialised in MIDI files for processing.","title":"What isobar does"},{"location":"#what-isobar-doesnt-do","text":"isobar does not generate any audio on its own. It must be configured to send events to an output device which is responsible for sound synthesis.","title":"What isobar doesn't do"},{"location":"#basic-concepts","text":"There are a few key components in isobar. The Timeline handles timing and scheduling, triggering events at the correct moment. It can maintain its own clock with millisecond accuracy, or sync to an external clock. Events correspond to triggers that are typically sent to output devices or received from input devices. These may be MIDI notes, control changes, OSC triggers, and other general types. An event is typically described by a dict with a number of properties. For example: { \"note\" : 60, \"amplitude\": 127 } Patterns : Each of the elements of an event can be specified by a Pattern, which generates a sequence of return values. Simple pattern types generate fixed sequences, random values, or values based on statistical models. Patterns can be passed other patterns as parameters, so they can operate on each other -- for example, causing an input pattern to loop N times, or skipping the input values with some probability. Devices : Events are sent to output devices, over interfaces such as MIDI or OSC. Events can also be received and processed.","title":"Basic concepts"},{"location":"#documentation","text":"Getting started Code examples Pattern library reference","title":"Documentation"},{"location":"about/","text":"About the project isobar was first designed for the generative sound installation Variable 4 , in which it was used to generate musical structures in response to changing weather conditions. It was more recently used in The Listening Machine , taking live input from Twitter and generating musical output from language patterns, streamed live over the internet. Many of the concepts behind Pattern and its subclasses are inspired by the brilliant pattern library of the SuperCollider synthesis language.","title":"About the project"},{"location":"about/#about-the-project","text":"isobar was first designed for the generative sound installation Variable 4 , in which it was used to generate musical structures in response to changing weather conditions. It was more recently used in The Listening Machine , taking live input from Twitter and generating musical output from language patterns, streamed live over the internet. Many of the concepts behind Pattern and its subclasses are inspired by the brilliant pattern library of the SuperCollider synthesis language.","title":"About the project"},{"location":"contributing/","text":"Contributing Third-party contributions are welcomed. Please read the CONTRIBUTING.md , and submit a pull request on GitHub .","title":"Contributing"},{"location":"contributing/#contributing","text":"Third-party contributions are welcomed. Please read the CONTRIBUTING.md , and submit a pull request on GitHub .","title":"Contributing"},{"location":"example/","text":"isobar isobar is a Python library for creating and manipulating musical patterns, designed for use in algorithmic composition, generative music and sonification. It makes it quick and easy to express complex musical ideas, and can send and receive events from various different sources: MIDI, OSC, SocketIO, and .mid files. Documentation index.md # The documentation homepage. ... # Other markdown pages, images and other files. Installation in a virtual environment The best way to make sure that you end up with the correct versions and without any incompatibility problems between packages it to use a virtual environment . Don't know what this is or how to set it up? We recommend to start by reading a [tutorial on virtual environments][6] for Python. Installation on macOS When you're running the pre-installed version of Python on macOS, pip tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this: Unix docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material Windows docker run --rm -it -p 8000:8000 -v \"%cd%\":/docs squidfunk/mkdocs-material","title":"isobar"},{"location":"example/#isobar","text":"isobar is a Python library for creating and manipulating musical patterns, designed for use in algorithmic composition, generative music and sonification. It makes it quick and easy to express complex musical ideas, and can send and receive events from various different sources: MIDI, OSC, SocketIO, and .mid files.","title":"isobar"},{"location":"example/#documentation","text":"index.md # The documentation homepage. ... # Other markdown pages, images and other files. Installation in a virtual environment The best way to make sure that you end up with the correct versions and without any incompatibility problems between packages it to use a virtual environment . Don't know what this is or how to set it up? We recommend to start by reading a [tutorial on virtual environments][6] for Python. Installation on macOS When you're running the pre-installed version of Python on macOS, pip tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this: Unix docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material Windows docker run --rm -it -p 8000:8000 -v \"%cd%\":/docs squidfunk/mkdocs-material","title":"Documentation"},{"location":"getting-started/","text":"Getting started Requirements isobar has been tested on Linux (Ubuntu, Raspberry Pi OS) and macOS. It has not been officially tested on Windows, although third-party contributions of support and QA efforts would be welcomed. It requires Python 3.5. 1. Install isobar The simplest way to install isobar is via pip : pip3 install isobar To download the examples, you will need to clone the repo and install from source: git clone https : // github . com / ideoforms / isobar . git cd isobar pip3 install . 2. Set up an output device The example scripts are based on sending MIDI to a DAW or MIDI-compatible hardware instrument. By default, isobar uses the system's default MIDI output as its output device. If you want to specify a non-standard MIDI output, you can specify it using an environmental variable: export ISOBAR_DEFAULT_MIDI_OUT = \"Prophet 6\" When you run an example script, you can confirm that it is using the right output as it will print the name of the output device it is using. 3. Run an example Inside the repo directory you cloned above, there are a number of example scripts. To run the \"hello world\" example: python3 examples / 00. ex - hello - world . py The script will print the default MIDI driver to screen, and begin triggering notes. Tip If you don't hear any notes, check that: the name of the correct device is printed to the console your device is configured to listen for MIDI on channel 1, and can play the note 60 Use a MIDI monitor utility to check that the events are registering correctly. Next steps Code examples Read about Patterns , Timelines , Events and Devices ,","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#requirements","text":"isobar has been tested on Linux (Ubuntu, Raspberry Pi OS) and macOS. It has not been officially tested on Windows, although third-party contributions of support and QA efforts would be welcomed. It requires Python 3.5.","title":"Requirements"},{"location":"getting-started/#1-install-isobar","text":"The simplest way to install isobar is via pip : pip3 install isobar To download the examples, you will need to clone the repo and install from source: git clone https : // github . com / ideoforms / isobar . git cd isobar pip3 install .","title":"1. Install isobar"},{"location":"getting-started/#2-set-up-an-output-device","text":"The example scripts are based on sending MIDI to a DAW or MIDI-compatible hardware instrument. By default, isobar uses the system's default MIDI output as its output device. If you want to specify a non-standard MIDI output, you can specify it using an environmental variable: export ISOBAR_DEFAULT_MIDI_OUT = \"Prophet 6\" When you run an example script, you can confirm that it is using the right output as it will print the name of the output device it is using.","title":"2. Set up an output device"},{"location":"getting-started/#3-run-an-example","text":"Inside the repo directory you cloned above, there are a number of example scripts. To run the \"hello world\" example: python3 examples / 00. ex - hello - world . py The script will print the default MIDI driver to screen, and begin triggering notes. Tip If you don't hear any notes, check that: the name of the correct device is printed to the console your device is configured to listen for MIDI on channel 1, and can play the note 60 Use a MIDI monitor utility to check that the events are registering correctly.","title":"3. Run an example"},{"location":"getting-started/#next-steps","text":"Code examples Read about Patterns , Timelines , Events and Devices ,","title":"Next steps"},{"location":"license/","text":"License isobar is under the MIT license . This means that you are welcome to use it for any purpose, including commercial usage, but must include the copyright notice above in any copies or derivative works. Please do let me know what you use it for!","title":"License"},{"location":"license/#license","text":"isobar is under the MIT license . This means that you are welcome to use it for any purpose, including commercial usage, but must include the copyright notice above in any copies or derivative works. Please do let me know what you use it for!","title":"License"},{"location":"devices/","text":"Devices and I/O MIDI isobar's MIDI support is based entirely on the fantastic mido library. MIDI file OpenSoundControl SuperCollider SignalFlow","title":"Devices and I/O"},{"location":"devices/#devices-and-io","text":"","title":"Devices and I/O"},{"location":"devices/#midi","text":"isobar's MIDI support is based entirely on the fantastic mido library.","title":"MIDI"},{"location":"devices/#midi-file","text":"","title":"MIDI file"},{"location":"devices/#opensoundcontrol","text":"","title":"OpenSoundControl"},{"location":"devices/#supercollider","text":"","title":"SuperCollider"},{"location":"devices/#signalflow","text":"","title":"SignalFlow"},{"location":"events/","text":"Events Events are scheduled by passing a dict to Timeline.schedule() , which inspects the keys to figure out what type of event you are intending. Event dicts with a note or degree key are assumed to be note events Event dicts with a control or program_change key are assumed to be control events Event dicts with an action key is assumed to be an action event Event types Note events trigger discrete MIDI notes, with a duration and amplitude Control events include MIDI control change, program change and pitchwheel messages, and can apply quasi-continuous control curves Action events call arbitrary Python functions","title":"Events"},{"location":"events/#events","text":"Events are scheduled by passing a dict to Timeline.schedule() , which inspects the keys to figure out what type of event you are intending. Event dicts with a note or degree key are assumed to be note events Event dicts with a control or program_change key are assumed to be control events Event dicts with an action key is assumed to be an action event","title":"Events"},{"location":"events/#event-types","text":"Note events trigger discrete MIDI notes, with a duration and amplitude Control events include MIDI control change, program change and pitchwheel messages, and can apply quasi-continuous control curves Action events call arbitrary Python functions","title":"Event types"},{"location":"events/action/","text":"Action events Action events trigger Python functions.","title":"Action events"},{"location":"events/action/#action-events","text":"Action events trigger Python functions.","title":"Action events"},{"location":"events/control/","text":"Control events Interpolation","title":"Control events"},{"location":"events/control/#control-events","text":"","title":"Control events"},{"location":"events/control/#interpolation","text":"","title":"Interpolation"},{"location":"events/note/","text":"Notes and MIDI events Notes and names A common approach to composition in isobar is building up patterns of notes, which correspond to the standard MIDI note range (0..127, with 60 = middle C) and velocity range (0..127). timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 64 , 67 , 72 ], 1 ), \"amplitude\" : 64 }) To get a note from its string representation, use the note_name_to_midi_note utility function: >>> print ( iso . note_name_to_midi_note ( \"G#2\" )) 32 Note events support the following properties: property type description note int MIDI note value amplitude int MIDI note velocity duration float Interval between notes (seconds) gate float Proportion of note to sustain (where 1.0 = legato) key Key Key for degree lookup scale Scale Scale for degree lookup degree int Degree within key/scale (cannot be used if note is specified) transpose int MIDI note transpose octave int MIDI note octave transpose Duration and gate The duration specifies the interval between one note and the next. The gate key specifies what proportion of this interval the note will be sustained for (and defaults to 1.0, for seamless legato). For instance: #-------------------------------------------------------------------------------- # Play a note every beat, sustained for half a beat #-------------------------------------------------------------------------------- timeline . schedule ({ \"note\" : 60 \"duration\" : 1 , \"gate\" : 0.5 }) The gate can also be greater than 1, to hold a note down as the next note begins: #-------------------------------------------------------------------------------- # Play a sustained, overlapping chord, with each note lasting for 4 beats #-------------------------------------------------------------------------------- timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 64 , 67 , 72 ], 1 ), \"duration\" : 0.5 , \"gate\" : 8 }) Keys and Scales isobar has builtin objects representing musical keys and scales. Scale encapsulates an ordered set of semitones. Named scales are defined corresponding to commonly-used scales ( major , minor , chromatic , aeolian , etc). Key encapsulates a Scale with a specified tonic. Warning isobar currently only supports equal temperament tuning. Keys and scales can be used in events by using the degree key to look up a specific degree within the key/scale. transpose and octave can be used to transpose by semitones and octaves respectively. #-------------------------------------------------------------------------------- # Play an F minor arpeggio #-------------------------------------------------------------------------------- timeline . schedule ({ \"degree\" : iso . PSequence ([ 0 , 2 , 4 , 7 ], 1 ), \"key\" : iso . Key ( \"F\" , \"minor\" ), \"octave\" : 4 }) Chords Chords can be specified by passing tuples of notes to the note or degree property. #-------------------------------------------------------------------------------- # Play an F minor arpeggio #-------------------------------------------------------------------------------- timeline . schedule ({ \"degree\" : iso . PSequence ([ ( 0 , 1 , 4 ), ( 1 , 4 , 6 ), ( 3 , 4 , 7 ), ( - 1 , 0 , 4 ), ]), \"octave\" : 4 , \"duration\" : 2 }) Rests Use None to specify a rest: timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 60 , None , 60 , None , 60 , 60 , None ]), \"duration\" : 0.25 }) Many Pattern classes can operate explicitly on rests, or introduce rests. For example: PCollapse takes an input and steps past any rests to remove gaps PSkipIf replaces notes with rests randomly given a probability PPad pads a sequence with rests until it reaches a specified length","title":"Note events"},{"location":"events/note/#notes-and-midi-events","text":"","title":"Notes and MIDI events"},{"location":"events/note/#notes-and-names","text":"A common approach to composition in isobar is building up patterns of notes, which correspond to the standard MIDI note range (0..127, with 60 = middle C) and velocity range (0..127). timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 64 , 67 , 72 ], 1 ), \"amplitude\" : 64 }) To get a note from its string representation, use the note_name_to_midi_note utility function: >>> print ( iso . note_name_to_midi_note ( \"G#2\" )) 32 Note events support the following properties: property type description note int MIDI note value amplitude int MIDI note velocity duration float Interval between notes (seconds) gate float Proportion of note to sustain (where 1.0 = legato) key Key Key for degree lookup scale Scale Scale for degree lookup degree int Degree within key/scale (cannot be used if note is specified) transpose int MIDI note transpose octave int MIDI note octave transpose","title":"Notes and names"},{"location":"events/note/#duration-and-gate","text":"The duration specifies the interval between one note and the next. The gate key specifies what proportion of this interval the note will be sustained for (and defaults to 1.0, for seamless legato). For instance: #-------------------------------------------------------------------------------- # Play a note every beat, sustained for half a beat #-------------------------------------------------------------------------------- timeline . schedule ({ \"note\" : 60 \"duration\" : 1 , \"gate\" : 0.5 }) The gate can also be greater than 1, to hold a note down as the next note begins: #-------------------------------------------------------------------------------- # Play a sustained, overlapping chord, with each note lasting for 4 beats #-------------------------------------------------------------------------------- timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 64 , 67 , 72 ], 1 ), \"duration\" : 0.5 , \"gate\" : 8 })","title":"Duration and gate"},{"location":"events/note/#keys-and-scales","text":"isobar has builtin objects representing musical keys and scales. Scale encapsulates an ordered set of semitones. Named scales are defined corresponding to commonly-used scales ( major , minor , chromatic , aeolian , etc). Key encapsulates a Scale with a specified tonic. Warning isobar currently only supports equal temperament tuning. Keys and scales can be used in events by using the degree key to look up a specific degree within the key/scale. transpose and octave can be used to transpose by semitones and octaves respectively. #-------------------------------------------------------------------------------- # Play an F minor arpeggio #-------------------------------------------------------------------------------- timeline . schedule ({ \"degree\" : iso . PSequence ([ 0 , 2 , 4 , 7 ], 1 ), \"key\" : iso . Key ( \"F\" , \"minor\" ), \"octave\" : 4 })","title":"Keys and Scales"},{"location":"events/note/#chords","text":"Chords can be specified by passing tuples of notes to the note or degree property. #-------------------------------------------------------------------------------- # Play an F minor arpeggio #-------------------------------------------------------------------------------- timeline . schedule ({ \"degree\" : iso . PSequence ([ ( 0 , 1 , 4 ), ( 1 , 4 , 6 ), ( 3 , 4 , 7 ), ( - 1 , 0 , 4 ), ]), \"octave\" : 4 , \"duration\" : 2 })","title":"Chords"},{"location":"events/note/#rests","text":"Use None to specify a rest: timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 60 , None , 60 , None , 60 , 60 , None ]), \"duration\" : 0.25 }) Many Pattern classes can operate explicitly on rests, or introduce rests. For example: PCollapse takes an input and steps past any rests to remove gaps PSkipIf replaces notes with rests randomly given a probability PPad pads a sequence with rests until it reaches a specified length","title":"Rests"},{"location":"patterns/","text":"Patterns About patterns Patterns are the fundamental building blocks that are used to create melodies, rhythms and control sequences. In Python terms, a pattern is an iterator , which is to say it does two things: generates and returns the next item in the sequence when no more items are available in the sequence, raises a StopIteration exception >>> seq = iso . PSequence ([ 1 , 2 , 3 ], 1 ) >>> next ( seq ) 1 >>> next ( seq ) 2 >>> next ( seq ) 3 >>> next ( seq ) Traceback ( most recent call last ): File \"sequence.py\" , line 46 , in __next__ raise StopIteration StopIteration Note that this means that patterns can't seek backwards in time. Their only concern is generating the next event. By assigning patterns to properties of events , you can specify sequences of values to control any aspect of the control output: pitch, velocity, duration, etc. Patterns can be finite, such as the example above, or infinite, in which case they will keep generating new values forever. Patterns can also typically generate different Python types. Some Pattern classes will seek to do the right thing based on whether they are passed them int or float arguments. PSequence([ \"apple\", \"pear\" ]) generates an alternating pair of strings PWhite(0, 10) generates a stream of ints between [0 .. 9] PWhite(0.0, 10.0) generates a stream of floats between [0.0 .. 10.0] PChoice([ Key(\"C\", \"major\"), Key(\"A\", \"minor\") ]) picks one of the specified Key s at random Pattern operators Patterns can be combined and modified using standard Python arithmetic operators, with other patterns or with scalar values. >>> added = iso . PSequence ([ 1 , 2 , 3 ]) + 10 >>> next ( added ) 11 >>> next ( added ) 12 >>> multiplied = iso . PSequence ([ 1 , 2 , 3 ]) * 4 >>> next ( added ) 4 >>> next ( added ) 8 >>> inverted = 12 - iso . PSequence ([ 1 , 2 , 3 ]) >>> next ( inverted ) 11 >>> next ( inverted ) 10 combined = iso . PSequence ([ 1 , 2 , 3 ]) + iso . PSequence ([ 12 , 0 , 12 ]) >>> next ( combined ) 13 >>> next ( combined ) 2 The operators are designed to do what you would expect: binary operators ( + , - , * , / , % , << , >> ) perform the operation on each item of the input patterns. Note that, for binary operators, if either of the inputs returns None , the output value becomes None . equality operators ( < , > , == , != ) can be used to do element-wise comparison on the input sequences, returning a pattern whose values are either True , False or None . abs() can be used to generate the absolute values of a sequence For finite sequences, len() will return the length of the sequence A float pattern can be turned into an int pattern with isobar.PInt(pattern) Duplicating patterns It's often useful to be able to apply the same pattern to multiple properties or events. However, this can result in unwanted behaviours as shown below: >>> a = iso . PSequence ([ 1 , 2 , 3 ]) >>> d = iso . PDict ({ \"p1\" : a , \"p2\" : a }) >>> next ( d ) { 'p1' : 1 , 'p2' : 2 } Because the \"p1\" and \"p2\" properties both refer to the same instance, the next() method is called twice on a . Instead, use a.copy() to create a duplicate with identical state: >>> a = iso . PSequence ([ 1 , 2 , 3 ]) >>> d = iso . PDict ({ \"p1\" : a . copy (), \"p2\" : a . copy () }) >>> next ( d ) { 'p1' : 1 , 'p2' : 1 } Resetting a pattern To rewind a pattern to its initial state, call pattern.reset() . This restores all state variables to their original values. Stochastic patterns Stochastic patterns each have their own independent random number generator state. This allows them to be seeded with a known value to create repeatable pseudo-random number sequences. >>> a = iso . PWhite ( 0 , 10 ) >>> a . seed ( 123 ) >>> a . nextn ( 16 ) [ 0 , 0 , 4 , 1 , 9 , 0 , 5 , 3 , 8 , 1 , 3 , 3 , 2 , 0 , 4 , 0 ] >>> a . seed ( 123 ) >>> a . nextn ( 16 ) [ 0 , 0 , 4 , 1 , 9 , 0 , 5 , 3 , 8 , 1 , 3 , 3 , 2 , 0 , 4 , 0 ] Static patterns Regular patterns are detached from the environmental state; their internal state steps forward each time their next() method is called. Static patterns, conversely, are not modified by a call to next() . This means that next() may be called multiple times and return the same value each time. Static patterns may be used to impose specific temporal structure on a piece. For example, to modulate over a set of keys: #-------------------------------------------------------------------------------- # Create a pattern which is an alternating pair of Keys. #-------------------------------------------------------------------------------- key_sequence = iso . PSequence ([ iso . Key ( \"C\" , \"minor\" ), iso . Key ( \"G\" , \"major\" ), ]) #-------------------------------------------------------------------------------- # Create a static pattern embeds the key_sequence pattern. # Each value will be held for 4 beats before progressing to the next value. #-------------------------------------------------------------------------------- key_static = iso . PStaticPattern ( key_sequence , 4 ) #-------------------------------------------------------------------------------- # Schedule a pattern which plays notes following the given keys. # A \"C\" note will be played for 4 notes, followed by a \"G\" for 4 notes, # repeatedly. #-------------------------------------------------------------------------------- timeline = iso . Timeline ( 120 ) timeline . schedule ({ \"degree\" : 0 , \"octave\" : 5 \"key\" : key_static , }) Globals The Globals class, and accompanying PGlobals pattern, can be used to share common variables across an isobar composition. For example: #-------------------------------------------------------------------------------- # Create a stream of events that will skip each note based on a \"density\" # global, with a key set by the \"key\" global. #-------------------------------------------------------------------------------- iso . Globals . set ( \"density\" , 0.5 ) iso . Globals . set ( \"key\" , iso . Key ( \"A\" , \"minor\" )) p = iso . PDict ({ \"degree\" : iso . PSkip ( 0 , iso . PGlobals ( \"density\" )), \"key\" : iso . PGlobals ( \"key\" ) })","title":"About patterns"},{"location":"patterns/#patterns","text":"","title":"Patterns"},{"location":"patterns/#about-patterns","text":"Patterns are the fundamental building blocks that are used to create melodies, rhythms and control sequences. In Python terms, a pattern is an iterator , which is to say it does two things: generates and returns the next item in the sequence when no more items are available in the sequence, raises a StopIteration exception >>> seq = iso . PSequence ([ 1 , 2 , 3 ], 1 ) >>> next ( seq ) 1 >>> next ( seq ) 2 >>> next ( seq ) 3 >>> next ( seq ) Traceback ( most recent call last ): File \"sequence.py\" , line 46 , in __next__ raise StopIteration StopIteration Note that this means that patterns can't seek backwards in time. Their only concern is generating the next event. By assigning patterns to properties of events , you can specify sequences of values to control any aspect of the control output: pitch, velocity, duration, etc. Patterns can be finite, such as the example above, or infinite, in which case they will keep generating new values forever. Patterns can also typically generate different Python types. Some Pattern classes will seek to do the right thing based on whether they are passed them int or float arguments. PSequence([ \"apple\", \"pear\" ]) generates an alternating pair of strings PWhite(0, 10) generates a stream of ints between [0 .. 9] PWhite(0.0, 10.0) generates a stream of floats between [0.0 .. 10.0] PChoice([ Key(\"C\", \"major\"), Key(\"A\", \"minor\") ]) picks one of the specified Key s at random","title":"About patterns"},{"location":"patterns/#pattern-operators","text":"Patterns can be combined and modified using standard Python arithmetic operators, with other patterns or with scalar values. >>> added = iso . PSequence ([ 1 , 2 , 3 ]) + 10 >>> next ( added ) 11 >>> next ( added ) 12 >>> multiplied = iso . PSequence ([ 1 , 2 , 3 ]) * 4 >>> next ( added ) 4 >>> next ( added ) 8 >>> inverted = 12 - iso . PSequence ([ 1 , 2 , 3 ]) >>> next ( inverted ) 11 >>> next ( inverted ) 10 combined = iso . PSequence ([ 1 , 2 , 3 ]) + iso . PSequence ([ 12 , 0 , 12 ]) >>> next ( combined ) 13 >>> next ( combined ) 2 The operators are designed to do what you would expect: binary operators ( + , - , * , / , % , << , >> ) perform the operation on each item of the input patterns. Note that, for binary operators, if either of the inputs returns None , the output value becomes None . equality operators ( < , > , == , != ) can be used to do element-wise comparison on the input sequences, returning a pattern whose values are either True , False or None . abs() can be used to generate the absolute values of a sequence For finite sequences, len() will return the length of the sequence A float pattern can be turned into an int pattern with isobar.PInt(pattern)","title":"Pattern operators"},{"location":"patterns/#duplicating-patterns","text":"It's often useful to be able to apply the same pattern to multiple properties or events. However, this can result in unwanted behaviours as shown below: >>> a = iso . PSequence ([ 1 , 2 , 3 ]) >>> d = iso . PDict ({ \"p1\" : a , \"p2\" : a }) >>> next ( d ) { 'p1' : 1 , 'p2' : 2 } Because the \"p1\" and \"p2\" properties both refer to the same instance, the next() method is called twice on a . Instead, use a.copy() to create a duplicate with identical state: >>> a = iso . PSequence ([ 1 , 2 , 3 ]) >>> d = iso . PDict ({ \"p1\" : a . copy (), \"p2\" : a . copy () }) >>> next ( d ) { 'p1' : 1 , 'p2' : 1 }","title":"Duplicating patterns"},{"location":"patterns/#resetting-a-pattern","text":"To rewind a pattern to its initial state, call pattern.reset() . This restores all state variables to their original values.","title":"Resetting a pattern"},{"location":"patterns/#stochastic-patterns","text":"Stochastic patterns each have their own independent random number generator state. This allows them to be seeded with a known value to create repeatable pseudo-random number sequences. >>> a = iso . PWhite ( 0 , 10 ) >>> a . seed ( 123 ) >>> a . nextn ( 16 ) [ 0 , 0 , 4 , 1 , 9 , 0 , 5 , 3 , 8 , 1 , 3 , 3 , 2 , 0 , 4 , 0 ] >>> a . seed ( 123 ) >>> a . nextn ( 16 ) [ 0 , 0 , 4 , 1 , 9 , 0 , 5 , 3 , 8 , 1 , 3 , 3 , 2 , 0 , 4 , 0 ]","title":"Stochastic patterns"},{"location":"patterns/#static-patterns","text":"Regular patterns are detached from the environmental state; their internal state steps forward each time their next() method is called. Static patterns, conversely, are not modified by a call to next() . This means that next() may be called multiple times and return the same value each time. Static patterns may be used to impose specific temporal structure on a piece. For example, to modulate over a set of keys: #-------------------------------------------------------------------------------- # Create a pattern which is an alternating pair of Keys. #-------------------------------------------------------------------------------- key_sequence = iso . PSequence ([ iso . Key ( \"C\" , \"minor\" ), iso . Key ( \"G\" , \"major\" ), ]) #-------------------------------------------------------------------------------- # Create a static pattern embeds the key_sequence pattern. # Each value will be held for 4 beats before progressing to the next value. #-------------------------------------------------------------------------------- key_static = iso . PStaticPattern ( key_sequence , 4 ) #-------------------------------------------------------------------------------- # Schedule a pattern which plays notes following the given keys. # A \"C\" note will be played for 4 notes, followed by a \"G\" for 4 notes, # repeatedly. #-------------------------------------------------------------------------------- timeline = iso . Timeline ( 120 ) timeline . schedule ({ \"degree\" : 0 , \"octave\" : 5 \"key\" : key_static , })","title":"Static patterns"},{"location":"patterns/#globals","text":"The Globals class, and accompanying PGlobals pattern, can be used to share common variables across an isobar composition. For example: #-------------------------------------------------------------------------------- # Create a stream of events that will skip each note based on a \"density\" # global, with a key set by the \"key\" global. #-------------------------------------------------------------------------------- iso . Globals . set ( \"density\" , 0.5 ) iso . Globals . set ( \"key\" , iso . Key ( \"A\" , \"minor\" )) p = iso . PDict ({ \"degree\" : iso . PSkip ( 0 , iso . PGlobals ( \"density\" )), \"key\" : iso . PGlobals ( \"key\" ) })","title":"Globals"},{"location":"patterns/reference/","text":"Core View source: core.py Class Function Pattern Abstract superclass of all pattern generators. PConstant Returns a fixed value. PRef Contains a reference to another pattern, which can be replaced dynamically. PFunc Returns the value generated by a function. PArrayIndex Request a specified index from an array. PDict Construct a pattern from a dict of arrays, or an array of dicts. PDictKey Request a specified key from a dictionary. PConcatenate Concatenate the output of multiple sequences. PAbs Absolute value of input PInt Integer value of input PAdd Add elements of two patterns (shorthand: patternA + patternB) PSub Subtract elements of two patterns (shorthand: patternA - patternB) PMul Multiply elements of two patterns (shorthand: patternA * patternB) PDiv Divide elements of two patterns (shorthand: patternA / patternB) PFloorDiv Integer division (shorthand: patternA // patternB) PMod Modulo elements of two patterns (shorthand: patternA % patternB) PPow One pattern to the power of another (shorthand: patternA ** patternB) PLShift Binary left-shift (shorthand: patternA << patternB) PRShift Binary right-shift (shorthand: patternA << patternB) PEqual Return 1 if a == b, 0 otherwise (shorthand: patternA == patternB) PGreaterThanOrEqual Return 1 if a != b, 0 otherwise (shorthand: patternA != patternB) PGreaterThan Return 1 if a > b, 0 otherwise (shorthand: patternA > patternB) PGreaterThanOrEqual Return 1 if a >= b, 0 otherwise (shorthand: patternA >= patternB) PLessThan Return 1 if a < b, 0 otherwise (shorthand: patternA < patternB) PLessThanOrEqual Return 1 if a <= b, 0 otherwise (shorthand: patternA <= patternB) Scalar View source: scalar.py Class Function PChanged Outputs a 1 if the value of a pattern has changed. PDiff Outputs the difference between the current and previous values of an input pattern PSkipIf If skip is false, returns input ; otherwise, returns None. PNormalise Adaptively normalise input to [0..1] over a linear scale. PMap Apply an arbitrary function to an input pattern. PMapEnumerated Apply arbitrary function to input, passing a counter. PLinLin Map input from linear range [a,b] to linear range [c,d]. PLinExp Map input from linear range [a,b] to exponential range [c,d]. PRound Round input to N decimal places. PScalar Reduce tuples and lists into single scalar values, PWrap Wrap input note values within , . PIndexOf Find index of items from pattern in Sequence View source: sequence.py Class Function PSeries Arithmetic series, beginning at start , increment by step PRange Similar to PSeries, but specify a max/step value. PGeom Geometric series, beginning at start , multiplied by step PImpulse Outputs a 1 every events, otherwise 0. PLoop Repeats a finite pattern for n repeats. PPingPong Ping-pong input pattern back and forth N times. PCreep Loop length -note segment, progressing creep notes after repeats repeats. PStutter Play each note of pattern count times. PSubsequence Returns a finite subsequence of an input pattern. PReverse Reverses a finite sequence. PReset Resets pattern whenever trigger is true PCounter Increments a counter by 1 for each zero-crossing in trigger . PCollapse Skip over any rests in input PNoRepeats Skip over repeated values in input PPad Pad pattern with rests until it reaches length length . PPadToMultiple Pad pattern with rests until its length is divisible by multiple . PArpeggiator Arpeggiator. PEuclidean Generate Euclidean rhythms. PPermut Generate every permutation of count input items. PPatternGeneratorAction Each time its pattern is exhausted, request a new pattern by calling . PSequenceAction Iterate over an array, perform a function, and repeat. Chance View source: chance.py Class Function PWhite White noise between min and max . PBrown Brownian noise. PWalk Random walk around list. PChoice Pick a random element from values , weighted by optional weights . PSample Pick multiple random elements from values , weighted by optional weights , PShuffle Shuffled list. PShuffleInput Every n steps, take n values from pattern and reorder. PSkip Skip events with some probability, 1 - . PFlipFlop flip a binary bit with some probability. PSwitchOne Capture length input values; loop, repeatedly switching two adjacent values. Tonal View source: tonal.py Class Function PDegree Map scale index to MIDI notes in . PFilterByKey Filter notes based on their presence in . PNearestNoteInKey Return the nearest note in . PMidiNoteToFrequency Map MIDI note to frequency value. Static View source: static.py Class Function PStaticGlobal Static global value identified by a string, with OSC listener. PGlobals Static global value identified by a string. PStaticCurrentTime Returns the position (in beats) of the current timeline. Fade View source: fade.py Class Function PFadeNotewise Fade a pattern in/out by introducing notes at a gradual rate. PFadeNotewiseRandom Fade a pattern in/out by gradually introducing random notes. Markov View source: markov.py Class Function PMarkov First-order Markov chain generator. Lsystem View source: lsystem.py Class Function PLSystem integer sequence derived from Lindenmayer systems Warp View source: warp.py Class Function PWInterpolate Requests a new target warp value from pattern every length beats PWSine Sinosoidal warp, period length beats, amplitude +/- . PWRallantando Exponential deceleration to times the current tempo over length beats.","title":"Pattern library reference"},{"location":"patterns/reference/#core","text":"View source: core.py Class Function Pattern Abstract superclass of all pattern generators. PConstant Returns a fixed value. PRef Contains a reference to another pattern, which can be replaced dynamically. PFunc Returns the value generated by a function. PArrayIndex Request a specified index from an array. PDict Construct a pattern from a dict of arrays, or an array of dicts. PDictKey Request a specified key from a dictionary. PConcatenate Concatenate the output of multiple sequences. PAbs Absolute value of input PInt Integer value of input PAdd Add elements of two patterns (shorthand: patternA + patternB) PSub Subtract elements of two patterns (shorthand: patternA - patternB) PMul Multiply elements of two patterns (shorthand: patternA * patternB) PDiv Divide elements of two patterns (shorthand: patternA / patternB) PFloorDiv Integer division (shorthand: patternA // patternB) PMod Modulo elements of two patterns (shorthand: patternA % patternB) PPow One pattern to the power of another (shorthand: patternA ** patternB) PLShift Binary left-shift (shorthand: patternA << patternB) PRShift Binary right-shift (shorthand: patternA << patternB) PEqual Return 1 if a == b, 0 otherwise (shorthand: patternA == patternB) PGreaterThanOrEqual Return 1 if a != b, 0 otherwise (shorthand: patternA != patternB) PGreaterThan Return 1 if a > b, 0 otherwise (shorthand: patternA > patternB) PGreaterThanOrEqual Return 1 if a >= b, 0 otherwise (shorthand: patternA >= patternB) PLessThan Return 1 if a < b, 0 otherwise (shorthand: patternA < patternB) PLessThanOrEqual Return 1 if a <= b, 0 otherwise (shorthand: patternA <= patternB)","title":"Core"},{"location":"patterns/reference/#scalar","text":"View source: scalar.py Class Function PChanged Outputs a 1 if the value of a pattern has changed. PDiff Outputs the difference between the current and previous values of an input pattern PSkipIf If skip is false, returns input ; otherwise, returns None. PNormalise Adaptively normalise input to [0..1] over a linear scale. PMap Apply an arbitrary function to an input pattern. PMapEnumerated Apply arbitrary function to input, passing a counter. PLinLin Map input from linear range [a,b] to linear range [c,d]. PLinExp Map input from linear range [a,b] to exponential range [c,d]. PRound Round input to N decimal places. PScalar Reduce tuples and lists into single scalar values, PWrap Wrap input note values within , . PIndexOf Find index of items from pattern in","title":"Scalar"},{"location":"patterns/reference/#sequence","text":"View source: sequence.py Class Function PSeries Arithmetic series, beginning at start , increment by step PRange Similar to PSeries, but specify a max/step value. PGeom Geometric series, beginning at start , multiplied by step PImpulse Outputs a 1 every events, otherwise 0. PLoop Repeats a finite pattern for n repeats. PPingPong Ping-pong input pattern back and forth N times. PCreep Loop length -note segment, progressing creep notes after repeats repeats. PStutter Play each note of pattern count times. PSubsequence Returns a finite subsequence of an input pattern. PReverse Reverses a finite sequence. PReset Resets pattern whenever trigger is true PCounter Increments a counter by 1 for each zero-crossing in trigger . PCollapse Skip over any rests in input PNoRepeats Skip over repeated values in input PPad Pad pattern with rests until it reaches length length . PPadToMultiple Pad pattern with rests until its length is divisible by multiple . PArpeggiator Arpeggiator. PEuclidean Generate Euclidean rhythms. PPermut Generate every permutation of count input items. PPatternGeneratorAction Each time its pattern is exhausted, request a new pattern by calling . PSequenceAction Iterate over an array, perform a function, and repeat.","title":"Sequence"},{"location":"patterns/reference/#chance","text":"View source: chance.py Class Function PWhite White noise between min and max . PBrown Brownian noise. PWalk Random walk around list. PChoice Pick a random element from values , weighted by optional weights . PSample Pick multiple random elements from values , weighted by optional weights , PShuffle Shuffled list. PShuffleInput Every n steps, take n values from pattern and reorder. PSkip Skip events with some probability, 1 - . PFlipFlop flip a binary bit with some probability. PSwitchOne Capture length input values; loop, repeatedly switching two adjacent values.","title":"Chance"},{"location":"patterns/reference/#tonal","text":"View source: tonal.py Class Function PDegree Map scale index to MIDI notes in . PFilterByKey Filter notes based on their presence in . PNearestNoteInKey Return the nearest note in . PMidiNoteToFrequency Map MIDI note to frequency value.","title":"Tonal"},{"location":"patterns/reference/#static","text":"View source: static.py Class Function PStaticGlobal Static global value identified by a string, with OSC listener. PGlobals Static global value identified by a string. PStaticCurrentTime Returns the position (in beats) of the current timeline.","title":"Static"},{"location":"patterns/reference/#fade","text":"View source: fade.py Class Function PFadeNotewise Fade a pattern in/out by introducing notes at a gradual rate. PFadeNotewiseRandom Fade a pattern in/out by gradually introducing random notes.","title":"Fade"},{"location":"patterns/reference/#markov","text":"View source: markov.py Class Function PMarkov First-order Markov chain generator.","title":"Markov"},{"location":"patterns/reference/#lsystem","text":"View source: lsystem.py Class Function PLSystem integer sequence derived from Lindenmayer systems","title":"Lsystem"},{"location":"patterns/reference/#warp","text":"View source: warp.py Class Function PWInterpolate Requests a new target warp value from pattern every length beats PWSine Sinosoidal warp, period length beats, amplitude +/- . PWRallantando Exponential deceleration to times the current tempo over length beats.","title":"Warp"},{"location":"timelines/","text":"Timelines A Timeline schedules and executes events following a clock. By default, a Timeline creates its own internal clock at a specified tempo: timeline = iso . Timeline ( 120 ) timeline . run () You can set and query the tempo using the tempo property: >>> timeline . tempo = 140 >>> print ( timeline . tempo ) 140 Sync from clock in A Timeline can be synchronised from an external MIDI clock: midi_in = MidiInputDevice () timeline = iso . Timeline ( clock_source = midi_in ) timeline . run () MIDI start and stop events will be followed. Querying the timeline's tempo will give an estimate of the current bpm based on a moving average. Sync to clock out You can also drive external MIDI clocks from a Timeline, by specifying the send_clock argument when creating the output device. output_device = iso . MidiOutputDevice ( send_clock = True ) timeline = iso . Timeline ( 120 , output_device = output_device ) timeline . run () Scheduling events Scheduling events is done by passing a dict to the Timeline.schedule() method, which creates a new Track on the timeline. A timeline can have an unlimited number of tracks (unless you specify a limit with the max_tracks property). #-------------------------------------------------------------------------------- # Play a series of 5 notes with random velocities. # Delay by 1 beat before playback. #-------------------------------------------------------------------------------- timeline = iso . Timeline ( 120 ) timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 67 , 72 , 77 , 84 ], 1 ), \"duration\" : 0.5 , \"amplitude\" : iso . PWhite ( 0 , 128 ) }, delay = 1 ) timeline . run () Scheduling can be quantized or delayed by passing args to the schedule() method: quantize=N : quantize to the next N beats before beginning playback. For example, quantize=1 will quantize to the next beat. quantize=0.25 will quantize to a quarter-beat. delay=N : delay by N beats before beginning playback. If quantize and delay are both specified, quantization is applied, and the event is scheduled delay beats after the quantization time. Clock resolution and accuracy isobar's internal clock by default has a resolution of 480 ticks per beat (PPQN), which equates to a timing precision of 1ms at 120bpm. High-precision scheduling in Python is inherently limited by Python's global interpreter lock (GIL), which means that sub-millisecond accuracy is unfortunately not possible. The good news is that, when using Python 3+, jitter is pretty low: the unit test suite verifies that the host device is able to keep time to +/- 1ms, and passes on Linux and macOS. Nonlinear time Time warping and nonlinear time is a work in progress.","title":"About timelines"},{"location":"timelines/#timelines","text":"A Timeline schedules and executes events following a clock. By default, a Timeline creates its own internal clock at a specified tempo: timeline = iso . Timeline ( 120 ) timeline . run () You can set and query the tempo using the tempo property: >>> timeline . tempo = 140 >>> print ( timeline . tempo ) 140","title":"Timelines"},{"location":"timelines/#sync-from-clock-in","text":"A Timeline can be synchronised from an external MIDI clock: midi_in = MidiInputDevice () timeline = iso . Timeline ( clock_source = midi_in ) timeline . run () MIDI start and stop events will be followed. Querying the timeline's tempo will give an estimate of the current bpm based on a moving average.","title":"Sync from clock in"},{"location":"timelines/#sync-to-clock-out","text":"You can also drive external MIDI clocks from a Timeline, by specifying the send_clock argument when creating the output device. output_device = iso . MidiOutputDevice ( send_clock = True ) timeline = iso . Timeline ( 120 , output_device = output_device ) timeline . run ()","title":"Sync to clock out"},{"location":"timelines/#scheduling-events","text":"Scheduling events is done by passing a dict to the Timeline.schedule() method, which creates a new Track on the timeline. A timeline can have an unlimited number of tracks (unless you specify a limit with the max_tracks property). #-------------------------------------------------------------------------------- # Play a series of 5 notes with random velocities. # Delay by 1 beat before playback. #-------------------------------------------------------------------------------- timeline = iso . Timeline ( 120 ) timeline . schedule ({ \"note\" : iso . PSequence ([ 60 , 67 , 72 , 77 , 84 ], 1 ), \"duration\" : 0.5 , \"amplitude\" : iso . PWhite ( 0 , 128 ) }, delay = 1 ) timeline . run () Scheduling can be quantized or delayed by passing args to the schedule() method: quantize=N : quantize to the next N beats before beginning playback. For example, quantize=1 will quantize to the next beat. quantize=0.25 will quantize to a quarter-beat. delay=N : delay by N beats before beginning playback. If quantize and delay are both specified, quantization is applied, and the event is scheduled delay beats after the quantization time.","title":"Scheduling events"},{"location":"timelines/#clock-resolution-and-accuracy","text":"isobar's internal clock by default has a resolution of 480 ticks per beat (PPQN), which equates to a timing precision of 1ms at 120bpm. High-precision scheduling in Python is inherently limited by Python's global interpreter lock (GIL), which means that sub-millisecond accuracy is unfortunately not possible. The good news is that, when using Python 3+, jitter is pretty low: the unit test suite verifies that the host device is able to keep time to +/- 1ms, and passes on Linux and macOS.","title":"Clock resolution and accuracy"},{"location":"timelines/#nonlinear-time","text":"Time warping and nonlinear time is a work in progress.","title":"Nonlinear time"}]}
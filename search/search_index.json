{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"isobar","text":"<p>isobar is a Python library for creating and manipulating musical patterns, designed for use in algorithmic composition, generative music and sonification. It makes it quick and easy to express complex musical ideas, and can send and receive events from various different sources: MIDI, OSC, SocketIO, and .mid files.</p>"},{"location":"#what-isobar-does","title":"What isobar does","text":"<p>The core objective of isobar is to provide a framework for sequencing and triggering events, which may be MIDI messages, OSC events, triggers for third-party DSP engines such as SuperCollider, or even Python functions. (What types of event are supported?) </p> <p>It can be used to trigger events in real time, or to generate patterns that can be serialised as MIDI files and loaded into a DAW.</p> <p>It can sync to external clocks, or act as a clock source to external devices.  </p> <p>It can also load patterns serialised in MIDI files for processing.</p>"},{"location":"#what-isobar-doesnt-do","title":"What isobar doesn't do","text":"<p>isobar does not generate any audio on its own. It must be configured to send events to an output device which is responsible for sound synthesis.</p>"},{"location":"#basic-concepts","title":"Basic concepts","text":"<p>There are a few key components in isobar.</p> <ul> <li>The Timeline handles timing and scheduling, triggering events at the correct moment. It can maintain its own clock with millisecond accuracy, or sync to an external clock.  </li> <li>Events correspond to triggers that are typically sent to output devices or received from input devices. These may be MIDI notes, control changes, OSC triggers, and other general types. An event is typically described by a dict with a number of properties. For example: <code>{ \"note\" : 60, \"amplitude\": 127 }</code></li> <li>Patterns: Each of the properties of an event can be specified by a Pattern, which generates a sequence of return values. Simple pattern types generate fixed sequences, random values, or values based on statistical models. Patterns can be passed other patterns as parameters, so they can operate on each other -- for example, causing an input pattern to loop N times, or skipping the input values with some probability.  </li> <li>Devices: Events are sent to output devices, over interfaces such as MIDI or OSC. Events can also be received and processed. </li> </ul>"},{"location":"#flow-diagram","title":"Flow diagram","text":""},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting started</li> <li>Code examples</li> <li>Pattern library reference</li> </ul>"},{"location":"about/","title":"About the project","text":"<p>isobar was first designed for the generative sound installation Variable 4, in which it was used to generate musical structures in response to changing weather conditions. It was more recently used in The Listening Machine, taking live input from Twitter and generating musical output from language patterns, streamed live over the internet.</p> <p>Many of the concepts behind Pattern and its subclasses are inspired by the brilliant pattern library of the SuperCollider synthesis language.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Third-party contributions are welcomed.</p> <p>Please read the CONTRIBUTING.md, and submit a pull request on GitHub.</p>"},{"location":"example/","title":"isobar","text":"<p>isobar is a Python library for creating and manipulating musical patterns, designed for use in algorithmic composition, generative music and sonification. It makes it quick and easy to express complex musical ideas, and can send and receive events from various different sources: MIDI, OSC, SocketIO, and .mid files.</p>"},{"location":"example/#documentation","title":"Documentation","text":"<pre><code>    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>Installation in a virtual environment</p> <p>The best way to make sure that you end up with the correct versions and without any incompatibility problems between packages it to use a virtual environment. Don't know what this is or how to set it up? We recommend to start by reading a [tutorial on virtual environments][6] for Python.</p> <p>Installation on macOS</p> <p>When you're running the pre-installed version of Python on macOS, <code>pip</code> tries to install packages in a folder for which your user might not have the adequate permissions. There are two possible solutions for this:</p> Unix <pre><code>docker run --rm -it -p 8000:8000 -v ${PWD}:/docs squidfunk/mkdocs-material\n</code></pre> Windows <pre><code>docker run --rm -it -p 8000:8000 -v \"%cd%\":/docs squidfunk/mkdocs-material\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>A complete set of example scripts are included with isobar, demonstrating applications from simple sequencing functionality to more complex tasks such as clock sync, file I/O, etc.</p> <p>Examples</p> <p>Alternatively, to see how every function across the codebase can be used, browse the unit tests.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>isobar has been tested on Linux (Ubuntu, Raspberry Pi OS) and macOS. It has not been officially tested on Windows, although third-party contributions of support and QA efforts would be welcomed.</p> <p>It requires Python 3.5 or above. </p> <p>On Linux, the <code>libasound</code> and <code>libjack-dev</code> packages are also required:</p> <pre><code>apt install libasound2-dev libjack-dev\n</code></pre>"},{"location":"getting-started/#1-install-isobar","title":"1. Install isobar","text":"<p>The simplest way to install isobar is via <code>pip</code>:</p> <pre><code>pip3 install isobar\n</code></pre> <p>To download the examples, you will need to clone the repo and install from source:</p> <pre><code>git clone https://github.com/ideoforms/isobar.git\ncd isobar\npip3 install .\n</code></pre>"},{"location":"getting-started/#2-set-up-an-output-device","title":"2. Set up an output device","text":"<p>The example scripts are based on sending MIDI to a DAW or MIDI-compatible hardware instrument. By default, isobar uses the system's default MIDI output as its output device. If you want to specify a non-standard MIDI output, you can specify the name of the MIDI device when creating the Timeline, or set a global default output device by using an environmental variable:</p> <pre><code>export ISOBAR_DEFAULT_MIDI_OUT=\"Prophet 6\"\n</code></pre> <p>When you run an example script, you can confirm that it is using the right output as it will print the name of the output device it is using.</p>"},{"location":"getting-started/#3-run-an-example","title":"3. Run an example","text":"<p>Inside the repo directory you cloned above, there are a number of example scripts. To run the \"hello world\" example:</p> <pre><code>python3 examples/00.ex-hello-world.py\n</code></pre> <p>The script will print the default MIDI driver to screen, and begin triggering notes.</p> <p>Troubleshooting</p> <p>If you don't hear any notes, check that:</p> <ul> <li>the name of the correct device is printed to the console</li> <li>your device is configured to listen for MIDI on channel 1, and can play the note 60</li> </ul> <p>Use a MIDI monitor utility to check that the events are registering correctly.</p>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>Code examples</li> <li>Read about Patterns, Timelines, Events and Devices,</li> </ul>"},{"location":"license/","title":"License","text":"<p>isobar is under the MIT license.</p> <p>This means that you are welcome to use it for any purpose, including commercial usage, but must include the copyright notice above in any copies or derivative works.</p> <p>Please do let me know what you use it for! </p>"},{"location":"source-code/","title":"Source code","text":"<p>The source code for isobar is hosted on GitHub:</p> <p>github.com/ideoforms/isobar</p> <p>To clone the latest version:</p> <pre><code>git clone https://github.com/ideoforms/isobar.git\n</code></pre>"},{"location":"devices/","title":"Devices and I/O","text":"<p>isobar can send events to several different types of output device.</p> <ul> <li>MIDI: Send and/or receive live MIDI note, control and clock events, either to an external MIDI hardware device or a software MIDI host such as a DAW</li> <li>MIDI file: Generate and store MIDI sequences in a .mid file</li> <li>OpenSoundControl: Send events using the Open Sound Control network protocol</li> <li>SignalFlow: Trigger events in the SignalFlow synthesis engine.</li> <li>SuperCollider: Sends events to the SuperCollider synthesis server.</li> </ul>"},{"location":"devices/fluidsynth/","title":"FluidSynth","text":"<p>isobar can be used to trigger notes in the free FluidSynth software synthesizer.</p> <p>It requires the <code>pyfluidsynth</code> package:</p> <pre><code>pip install pyfluidsynth\n</code></pre>"},{"location":"devices/fluidsynth/#example","title":"Example","text":"<pre><code>from isobar import *\nfrom isobar.io.fluidsynth import FluidSynthOutputDevice\n\noutput_device = FluidSynthOutputDevice(\"/Users/daniel/Projects/IIL-Residency/fluidsynth/Touhou.sf2\")\ntimeline = Timeline(120, output_device=output_device)\n\ntimeline.schedule({\n    \"key\": Key(\"C\", \"minorPenta\"),\n    \"octave\": 5,\n    \"degree\": PLoop(PSubsequence(PWhite(0, 12), 0, 8)),\n    \"duration\": 0.25,\n}, quantize=None)\n\ntimeline.run()\n</code></pre>"},{"location":"devices/midi/","title":"MIDI","text":"<p>isobar's MIDI support is based on the excellent mido library. </p> <p>Two classes are available for MIDI I/O:</p>"},{"location":"devices/midi/#midioutputdevice","title":"MidiOutputDevice","text":"<p>Sends note and control events to a MIDI device. isobar can also act as the clock out, so that external MIDI devices follow isobar's internal clock.  </p> <p>Virtual MIDI devices</p> <p>To control a MIDI device on the same computer that is running isobar, you will need to create a virtual MIDI bus.</p> <pre><code>name = \"My MIDI Device Name\"\nmidi_out = iso.MidiOutputDevice(device_name=name,\n                                send_clock=True)\ntimeline = Timeline(tempo=120, output_device=midi_out)\n</code></pre> <ul> <li><code>device_name</code>: Specifies the device name to search for. Leave empty to use the system default.</li> <li><code>send_clock</code>: If True, sends clock sync signals to the external device.</li> </ul> <p>A default MIDI output device name can be set with an environmental variable:</p> <pre><code>export ISOBAR_DEFAULT_MIDI_OUT=\"Prophet 6\"\n</code></pre> <p>To list all available MIDI output devices:</p> <pre><code>print(iso.io.midi.get_midi_output_names())\n</code></pre>"},{"location":"devices/midi/#midiinputdevice","title":"MidiInputDevice","text":"<p>Receives notes and control events from a MIDI device, or sync isobar to an external MIDI clock.</p> <pre><code># Receive MIDI messages from an external device \nname = \"My MIDI Device Name\"\nmidi_in = iso.MidiInputDevice(device_name=name)\n\n# Blocking mode: waits until a message is received\nmessage = midi_in.receive()\n\n# Non-blocking: if a message is available, return it; otherwise, return None\nmessage = midi_in.poll()\n</code></pre> <pre><code># Sync a Timeline to a MIDI external clock \nname = \"My MIDI Device Name\"\nmidi_in = iso.MidiInputDevice(device_name=name)\ntimeline = Timeline(tempo=120, clock_source=midi_in)\n</code></pre> <p>A default MIDI input device name can be set with an environmental variable:</p> <pre><code>export ISOBAR_DEFAULT_MIDI_IN=\"Prophet 6\"\n</code></pre> <p>To list all available MIDI input devices:</p> <pre><code>print(iso.io.midi.get_midi_input_names())\n</code></pre>"},{"location":"devices/midifile/","title":"MIDI file","text":""},{"location":"devices/midifile/#midifileoutputdevice","title":"MidiFileOutputDevice","text":"<p>Writing MIDI files is done by setting the output device of a Timeline to a <code>MidiFileOutputDevice</code></p> <p>isobar normally generates events in real-time according to the tempo of the Timeline. To batch process events instantaneously, set the tempo of the timeline to <code>iso.MAX_CLOCK_RATE</code>. </p> <pre><code>filename = \"output.mid\"\noutput = MidiFileOutputDevice(filename)\n\ntimeline = iso.Timeline(iso.MAX_CLOCK_RATE, output_device=output)\ntimeline.stop_when_done = True\ntimeline.schedule({ \"note\": iso.PSequence([ 60, 62, 64, 65 ], 1) })\n\ntimeline.run()\noutput.write()\n</code></pre>"},{"location":"devices/midifile/#midifileinputdevice","title":"MidiFileInputDevice","text":"<p>Reading MIDI files is done with a <code>MidiFileInputDevice</code>.</p> <p>The method <code>MidiFileInputDevice.read()</code> returns a <code>PDict</code> containing <code>PSequence</code> patterns for each of the MIDI event properties (note, amplitude, duration), which can be scheduled for playback within a timeline:</p> <pre><code>pattern = MidiFileInputDevice(args.filename).read()\ntimeline = iso.Timeline()\ntimeline.schedule(pattern)\ntimeline.run()\n</code></pre> <p>To discard the amplitudes and durations, and make use of just the pitch values:</p> <pre><code>pattern = MidiFileInputDevice(args.filename).read()\ntimeline = iso.Timeline()\ntimeline.schedule({\n    \"note\": pattern[\"note\"],\n    \"duration\": 0.1\n})\ntimeline.run()\n</code></pre>"},{"location":"devices/osc/","title":"OpenSoundControl","text":"<p>isobar can be used to send Open Sound Control events to local or remote network hosts.</p> <p>To send a sequence of events to an OSC device: </p> <pre><code>osc_device = iso.OSCOutputDevice(\"127.0.0.1\", 8010)\ntimeline = iso.Timeline(120, output_device=osc_device)\ntimeline.schedule({\n    \"osc_address\": \"/freq\",\n    \"osc_params\": [\n        iso.PSequence([440, 880])\n    ]\n})\n</code></pre> <p>In the above: - <code>osc_address</code> is the OSC address path  - <code>osc_params</code> is an optional list of zero or more arguments, which can be of type <code>int</code>, <code>float</code>, <code>bool</code>, or <code>str</code>. Each argument's OSC type is automatically inferred from its Python type.</p> <p>Control-rate interpolation is not yet supported for OSC.</p>"},{"location":"devices/signalflow/","title":"SignalFlow","text":"<p>isobar can be used to control the SignalFlow Python synthesis framework.</p> <p>Three different types of event are supported, all of which interact with Patch objects:</p> <ul> <li>create a <code>Patch</code></li> <li>modify a parameter of a <code>Patch</code></li> <li>send a trigger event to a <code>Patch</code></li> </ul>"},{"location":"devices/signalflow/#create-a-patch","title":"Create a Patch","text":"<pre><code>from isobar import *\nfrom isobar.io.signalflow import SignalFlowOutputDevice\nfrom signalflow import *\n\nclass Ping (Patch):\n    def __init__(self, frequency: float = 440):\n        super().__init__()\n        envelope = ASREnvelope(0, 0, 0.5)\n        sine = SineOscillator(frequency)\n        output = sine * envelope * 0.25\n        self.set_output(output)\n        self.set_auto_free_node(envelope)\n\ngraph = AudioGraph()\noutput_device = SignalFlowOutputDevice(graph=graph)\ntimeline = Timeline(120, output_device=output_device)\ntimeline.schedule({\n    # If a Patch class is passed to the `patch` property, a patch of this class\n    # is created each time the event is triggered.\n    \"patch\": Ping,\n    \"duration\": 0.25,\n    \"params\": {\n        \"frequency\": PChoice([220, 440, 660, 880]),\n    }\n})\ntimeline.run()\n</code></pre>"},{"location":"devices/signalflow/#modify-a-parameter-of-a-patch","title":"Modify a parameter of a Patch","text":"<pre><code>from isobar import *\nfrom isobar.io.signalflow import SignalFlowOutputDevice\nfrom signalflow import *\n\nclass Tone (Patch):\n    def __init__(self, frequency: float = 440):\n        super().__init__()\n        frequency = self.add_input(\"frequency\", frequency)\n        sine = SineOscillator(frequency)\n        output = sine * 0.25\n        self.set_output(output)\n\ngraph = AudioGraph()\noutput_device = SignalFlowOutputDevice(graph=graph)\n\npatch = Tone()\npatch.play()\n\ntimeline = Timeline(120, output_device=output_device)\ntimeline.schedule({\n    \"patch\": patch,\n    \"duration\": 0.25,\n    \"params\": {\n        \"frequency\": PChoice([220, 440, 660, 880]),\n    }\n})\ntimeline.run()\n</code></pre>"},{"location":"devices/signalflow/#send-a-trigger-event-to-a-patch","title":"Send a trigger event to a Patch","text":"<pre><code>from isobar import *\nfrom isobar.io.signalflow import SignalFlowOutputDevice\nfrom signalflow import *\n\nclass Cymbal (Patch):\n    def __init__(self):\n        super().__init__()\n        noise = WhiteNoise()\n        envelope = ASREnvelope(0, 0, 0.1)\n        output = noise * envelope * 0.25\n        self.set_output(output)\n        self.set_trigger_node(envelope)\n\ngraph = AudioGraph()\noutput_device = SignalFlowOutputDevice(graph=graph)\n\ncymbal = Cymbal()\ncymbal.play()\n\ntimeline = Timeline(120, output_device=output_device)\ntimeline.schedule({\n    \"patch\": cymbal,\n    \"type\": \"trigger\",\n    \"duration\": PLoop(PTri(10, 0.1, 0.5)),\n})\ntimeline.run()\n</code></pre>"},{"location":"devices/supercollider/","title":"SuperCollider","text":"<p>isobar can be used to create and interact with SuperCollider synths. The python-supercollider module is required, which can be installed with:</p> <pre><code>pip install supercollider\n</code></pre>"},{"location":"devices/supercollider/#example","title":"Example","text":"<pre><code>import supercollider as sc\nimport isobar as iso\nimport logging\n\nserver = sc.Server()\nbuf = sc.Buffer.read(server, \"apollo.wav\")\n\noutput = iso.SuperColliderOutputDevice()\ntimeline = iso.Timeline(120, output)\n\ntimeline.schedule({\n    \"synth\": \"playbuf\",\n    \"params\": {\n        \"buffer\": buf,\n        \"rate\": iso.PSequence([ 1, 2, 0.5 ])\n    },\n    \"duration\": 1\n})\n\ntimeline.run()\n</code></pre>"},{"location":"devices/virtual-midi-devices/","title":"Virtual MIDI Devices","text":"<p>To send MIDI events to audio software running on the same computer (for example, to use isobar to trigger events in your DAW), you will generally need to set up a virtual MIDI driver. This lets you send MIDI messages between different applications.</p> <p>For cross-platform instructions on how to do this, see Setting up a virtual MIDI bus (Ableton).</p>"},{"location":"events/","title":"Events","text":"<p>Events are scheduled by passing a dict to <code>Timeline.schedule()</code>, which inspects the keys to figure out what type of event you are intending.</p> <ul> <li>Event dicts with a <code>note</code> or <code>degree</code> key are assumed to be <code>note</code> events</li> <li>Event dicts with a <code>control</code> or <code>program_change</code> key are assumed to be <code>control</code> events</li> <li>Event dicts with an <code>action</code> key is assumed to be an <code>action</code> event</li> </ul> <p>The default values for unspecified parameters in an Event dict are infinite patterns generated by <code>PConstant</code>. This means that, unless a finite parameter is explicitly passed, events will continue to be generated forever.</p>"},{"location":"events/#event-types","title":"Event types","text":"<ul> <li>Note events trigger discrete MIDI notes, with a duration and amplitude </li> <li>Control events include MIDI control change, program change and pitchwheel messages, and can apply quasi-continuous control curves</li> <li>Action events call arbitrary Python functions</li> </ul>"},{"location":"events/action/","title":"Action events","text":"<p>Action events trigger Python functions. Set the <code>action</code> property to a function or lambda, and it will be executed at the time of the event:</p> <pre><code>timeline.schedule({\n    \"action\": lambda: print(\"Hello world\")\n})\n</code></pre> <p>Observe that, when you run the above, it will print <code>Hello world</code> indefinitely, once per beat. Why is this?</p> <p>Just as for notes and other event types, the <code>duration</code> parameter of the event template defaults to an infinitely-repeating pattern generated by <code>PConstant</code>. To limit the number of repeats that an action performs, use the <code>count</code> argument:</p> <pre><code>timeline.schedule({\n    \"action\": lambda: print(round(timeline.current_time))\n}, count=4)\n</code></pre>"},{"location":"events/action/#action-arguments","title":"Action arguments","text":"<p>For more complex functions, custom named keyword arguments can be passed to the function using the <code>args</code> property</p> <p>This executes an action every 4 beats to change the global key of the piece, using the Globals variables:  </p> <pre><code>def set_key(k):\n    iso.Globals.set(\"key\", iso.Key(k))\n\ntimeline.schedule({\n    \"action\": set_key,\n    \"args\": {\n        \"k\": iso.PWhite(8)\n    },\n    \"duration\": 4\n})\ntimeline.schedule({\n    \"degree\": 0,\n    \"key\": iso.PGlobals(\"key\"),\n    \"octave\": 4\n})\n</code></pre>"},{"location":"events/control/","title":"Control events","text":"<p>MIDI control change events can be sequenced by specifying the integer <code>control</code> index and the <code>value</code> to set the control change to:</p> <pre><code>timeline.schedule({\n    \"control\": 0,\n    \"value\": iso.PWhite(0, 128),\n    \"duration\": 0.5\n})\n</code></pre> <p>The above example sets control index <code>0</code> to a value drawn from a uniformly distribution, once every half-beat. </p>"},{"location":"events/control/#interpolation","title":"Interpolation","text":"<p>To transmit smooth control curves, isobar can interpolate between control values. The resulting interpolated value is sent continuously to the output device.</p> <pre><code># Apply linear interpolation to smoothly fade between values.\ntimeline.schedule({\n    \"control\": 0,\n    \"value\": iso.PWhite(0, 128),\n    \"duration\": 0.5\n}, interpolate=\"linear\")\n</code></pre> <p>To jump instantaneously between values when interpolation is being used, simply set a <code>duration</code> of zero. The below applies sawtooth-shaped modulation to a control signal.</p> <pre><code>timeline.schedule({\n    \"control\": 0,\n    \"value\": iso.PSequence([ 0, 127 ]),\n    \"duration\": iso.PSequence([ 1, 0 ])\n}, interpolate=\"linear\")\n</code></pre> <p>Interpolation modes include:</p> <ul> <li><code>linear</code></li> <li><code>cosine</code> </li> </ul>"},{"location":"events/note/","title":"Notes and MIDI events","text":""},{"location":"events/note/#notes-and-names","title":"Notes and names","text":"<p>A common approach to composition in isobar is building up patterns of notes, which correspond to the standard MIDI note range (0..127, with 60 = middle C) and velocity range (0..127).</p> <pre><code>timeline.schedule({\n    \"note\": iso.PSequence([ 60, 64, 67, 72 ], 1),\n    \"amplitude\": 64\n})\n</code></pre> <p>To get a note from its string representation, use the <code>note_name_to_midi_note</code> utility function:</p> <pre><code>&gt;&gt;&gt; print(iso.note_name_to_midi_note(\"G#2\"))\n32\n</code></pre> <p>Note events support the following properties:</p> property type description note int MIDI note value amplitude int MIDI note velocity duration float Interval between notes (seconds) gate float Proportion of note to sustain (where 1.0 = legato) key Key Key for degree lookup scale Scale Scale for degree lookup degree int Degree within key/scale (cannot be used if note is specified) transpose int MIDI note transpose octave int MIDI note octave transpose active int If false, skips the note"},{"location":"events/note/#duration-and-gate","title":"Duration and gate","text":"<p>The <code>duration</code> specifies the interval between one note and the next. The <code>gate</code> key specifies what proportion of this interval the note will be sustained for (and defaults to 1.0, for seamless legato).</p> <p>For instance:</p> <pre><code>#--------------------------------------------------------------------------------\n# Play a note every beat, sustained for half a beat\n#--------------------------------------------------------------------------------\ntimeline.schedule({\n    \"note\": 60\n    \"duration\": 1,\n    \"gate\": 0.5\n})\n</code></pre> <p>The <code>gate</code> can also be greater than 1, to hold a note down as the next note begins:</p> <pre><code>#--------------------------------------------------------------------------------\n# Play a sustained, overlapping chord, with each note lasting for 4 beats\n#--------------------------------------------------------------------------------\ntimeline.schedule({\n    \"note\": iso.PSequence([ 60, 64, 67, 72 ], 1),\n    \"duration\": 0.5,\n    \"gate\": 8\n})\n</code></pre>"},{"location":"events/note/#keys-and-scales","title":"Keys and Scales","text":"<p>isobar has builtin objects representing musical keys and scales.</p> <ul> <li>Scale encapsulates an ordered set of semitones. Named scales are defined corresponding to commonly-used scales (<code>major</code>, <code>minor</code>, <code>chromatic</code>, <code>aeolian</code>, etc).</li> <li>Key encapsulates a Scale with a specified tonic.</li> </ul> <p>Warning</p> <p>isobar currently only supports equal temperament tuning. </p> <p>Keys and scales can be used in events by using the <code>degree</code> key to look up a specific degree within the key/scale. <code>transpose</code> and <code>octave</code> can be used to transpose by semitones and octaves respectively.  </p> <pre><code>#--------------------------------------------------------------------------------\n# Play an F minor arpeggio\n#--------------------------------------------------------------------------------\ntimeline.schedule({\n    \"degree\": iso.PSequence([ 0, 2, 4, 7 ], 1),\n    \"key\": iso.Key(\"F\", \"minor\"),\n    \"octave\": 4\n})\n</code></pre>"},{"location":"events/note/#chords","title":"Chords","text":"<p>Chords can be specified by passing tuples of notes to the <code>note</code> or <code>degree</code> property.</p> <pre><code>#--------------------------------------------------------------------------------\n# Play a series of 3-note chords.\n#--------------------------------------------------------------------------------\ntimeline.schedule({\n    \"degree\": iso.PSequence([\n        (0, 1, 4),\n        (1, 4, 6),\n        (3, 4, 7),\n        (-1, 0, 4),\n    ]),\n    \"octave\": 4,\n    \"duration\": 2\n})\n</code></pre> <p>You can also specify different amplitudes or gates for notes of a chord by passing tuples of the same length:</p> <pre><code>timeline.schedule({\n    \"note\": iso.PSequence([\n        (60, 62, 67),\n    ]),\n    \"gate\": iso.PSequence([\n        (0.25, 0.5, 1)\n    ]),\n    \"amplitude\": iso.PSequence([\n        (96, 64, 32),\n        (64, 96, 32),\n        (64, 32, 96),\n    ]),\n    \"duration\": 0.25\n})\n</code></pre>"},{"location":"events/note/#rests","title":"Rests","text":"<p>Use <code>None</code> to specify a rest:</p> <pre><code>timeline.schedule({\n    \"note\": iso.PSequence([ 60, 60, None, 60, None, 60, 60, None ]),\n    \"duration\": 0.25\n})\n</code></pre> <p>Many Pattern classes can operate explicitly on rests, or introduce rests.</p> <p>For example:</p> <ul> <li><code>PCollapse</code> takes an input and steps past any rests to remove gaps</li> <li><code>PSkipIf</code> replaces notes with rests given a conditional</li> <li><code>PSkip</code> replaces notes with rests randomly given a probability</li> <li><code>PPad</code> pads a sequence with rests until it reaches a specified length</li> </ul>"},{"location":"patterns/","title":"Patterns","text":""},{"location":"patterns/#about-patterns","title":"About patterns","text":"<p>Patterns are the fundamental building blocks that are used to create melodies, rhythms and control sequences. A pattern is a Python iterator, which is to say it does two things:</p> <ul> <li>generates and returns the next item in the sequence</li> <li>when no more items are available in the sequence, raises a <code>StopIteration</code> exception</li> </ul> <pre><code>&gt;&gt;&gt; seq = iso.PSequence([ 1, 2, 3 ], 1)\n&gt;&gt;&gt; next(seq)\n1\n&gt;&gt;&gt; next(seq)\n2\n&gt;&gt;&gt; next(seq)\n3\n&gt;&gt;&gt; next(seq)\nTraceback (most recent call last):\n  File \"sequence.py\", line 46, in __next__\n    raise StopIteration\nStopIteration\n</code></pre> <p>Note that this means that patterns can't seek backwards in time. Their only concern is generating the next event.</p> <p>By assigning patterns to properties of events, you can specify sequences of values to control any aspect of the control output: pitch, velocity, duration, etc.    </p> <p>Patterns can be finite, such as the example above, or infinite, in which case they will keep generating new values forever.</p> <p>Patterns can also typically generate different Python types. Some Pattern classes will seek to do the right thing based on whether they are passed int or float arguments.</p> <ul> <li><code>PSequence([ \"apple\", \"pear\" ])</code> generates an alternating pair of strings</li> <li><code>PWhite(0, 10)</code> generates a stream of ints between <code>[0 .. 9]</code></li> <li><code>PWhite(0.0, 10.0)</code> generates a stream of floats between <code>[0.0 .. 10.0]</code></li> <li><code>PChoice([ Key(\"C\", \"major\"), Key(\"A\", \"minor\") ])</code> picks one of the specified Keys at random</li> </ul>"},{"location":"patterns/#pattern-resolution","title":"Pattern resolution","text":"<p>When a pattern returns a pattern, the embedded pattern will also be resolved recursively. For example:</p> <ul> <li><code>PChoice([ PSequence([0, 2, 3]), PSequence([7, 5, 2 ]) ])</code> each step, picks one of the embedded patterns and returns its next value</li> </ul>"},{"location":"patterns/#pattern-operators","title":"Pattern operators","text":"<p>Patterns can be combined and modified using standard Python arithmetic operators, with other patterns or with scalar values.</p> <pre><code>&gt;&gt;&gt; added = iso.PSequence([ 1, 2, 3 ]) + 10\n&gt;&gt;&gt; next(added)\n11\n&gt;&gt;&gt; next(added)\n12\n\n&gt;&gt;&gt; multiplied = iso.PSequence([ 1, 2, 3 ]) * 4\n&gt;&gt;&gt; next(multiplied)\n4\n&gt;&gt;&gt; next(multiplied)\n8\n\n&gt;&gt;&gt; inverted = 12 - iso.PSequence([ 1, 2, 3 ])\n&gt;&gt;&gt; next(inverted)\n11\n&gt;&gt;&gt; next(inverted)\n10\n\ncombined = iso.PSequence([ 1, 2, 3 ]) + iso.PSequence([ 12, 0, 12 ])\n&gt;&gt;&gt; next(combined)\n13\n&gt;&gt;&gt; next(combined)\n2\n</code></pre> <p>The operators are designed to do what you would expect:</p> <ul> <li>binary operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>) perform the operation on each item of the input patterns. Note that, for binary operators, if either of the inputs returns <code>None</code>, the output value becomes <code>None</code>.</li> <li>equality operators (<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>!=</code>) can be used to do element-wise comparison on the input sequences, returning a pattern whose values are either <code>True</code>, <code>False</code> or <code>None</code>.</li> <li><code>abs()</code> can be used to generate the absolute values of a sequence</li> <li>For finite sequences, <code>len()</code> will return the length of the sequence</li> <li>A <code>float</code> pattern can be turned into an <code>int</code> pattern with <code>isobar.PInt(pattern)</code> </li> </ul>"},{"location":"patterns/#duplicating-patterns","title":"Duplicating patterns","text":"<p>It's often useful to be able to apply the same pattern to multiple properties or events.</p> <p>However, this can result in unwanted behaviours as shown below:</p> <pre><code>&gt;&gt;&gt; a = iso.PSequence([ 1, 2, 3 ])\n&gt;&gt;&gt; d = iso.PDict({ \"p1\" : a, \"p2\" : a })\n&gt;&gt;&gt; next(d)\n{'p1': 1, 'p2': 2}\n</code></pre> <p>Because the \"p1\" and \"p2\" properties both refer to the same instance, the <code>next()</code> method is called twice on <code>a</code>.</p> <p>Instead, use <code>a.copy()</code> to create a duplicate with identical state:</p> <pre><code>&gt;&gt;&gt; a = iso.PSequence([ 1, 2, 3 ])\n&gt;&gt;&gt; d = iso.PDict({ \"p1\" : a.copy(), \"p2\" : a.copy() })\n&gt;&gt;&gt; next(d)\n{'p1': 1, 'p2': 1}\n</code></pre>"},{"location":"patterns/#resetting-a-pattern","title":"Resetting a pattern","text":"<p>To rewind a pattern to its initial state, call <code>pattern.reset()</code>. This restores all state variables to their original values.</p>"},{"location":"patterns/#stochastic-patterns","title":"Stochastic patterns","text":"<p>Stochastic patterns each have their own independent random number generator state. This allows them to be seeded with a known value to create repeatable pseudo-random number sequences.</p> <pre><code>&gt;&gt;&gt; a = iso.PWhite(0, 10)\n&gt;&gt;&gt; a.seed(123)\n&gt;&gt;&gt; a.nextn(16)\n[0, 0, 4, 1, 9, 0, 5, 3, 8, 1, 3, 3, 2, 0, 4, 0]\n&gt;&gt;&gt; a.seed(123)\n&gt;&gt;&gt; a.nextn(16)\n[0, 0, 4, 1, 9, 0, 5, 3, 8, 1, 3, 3, 2, 0, 4, 0]\n</code></pre>"},{"location":"patterns/#static-patterns","title":"Static patterns","text":"<p>The state of a regular pattern steps forward each time the <code>next()</code> method is called.</p> <p>The state of a static pattern, conversely, is not modified by a call to <code>next()</code>. This means that <code>next()</code> may be called multiple times and return the same value each time.</p> <p>Static pattern classes include:</p> <ul> <li><code>PStaticPattern</code>: When called as <code>PStaticPattern(pattern, duration)</code>, wraps a regular pattern and returns a new static pattern. Each new value of the inner pattern is returned for a specified duration in beats (see example below). The <code>duration</code> parameter may also be a pattern. </li> <li><code>PCurrentTime</code>: Returns the current Timeline's time, in beats.</li> <li><code>PGlobals</code>: See Globals.</li> </ul> <p>Static patterns can be used to impose temporal structure on a piece. For example, to modulate over a set of keys:</p> <pre><code>#--------------------------------------------------------------------------------\n# Create a pattern which is an alternating pair of Keys.\n#--------------------------------------------------------------------------------\nkey_sequence = iso.PSequence([\n    iso.Key(\"C\", \"minor\"),\n    iso.Key(\"G\", \"major\"),\n])\n#--------------------------------------------------------------------------------\n# Create a static pattern embeds the key_sequence pattern.\n# Each value will be held for 4 beats before progressing to the next value.\n#--------------------------------------------------------------------------------\nkey_static = iso.PStaticPattern(key_sequence, 4)\n\n#--------------------------------------------------------------------------------\n# Schedule a pattern which plays notes following the given keys.\n# A \"C\" note will be played for 4 notes, followed by a \"G\" for 4 notes,\n# repeatedly. The same static pattern can be accessed by multiple different\n# tracks or timelines to orchestrate changes across the composition. \n#--------------------------------------------------------------------------------\ntimeline = iso.Timeline(120)\ntimeline.schedule({\n    \"degree\": 0,\n    \"octave\": 5,\n    \"key\": key_static,\n})\n</code></pre>"},{"location":"patterns/#globals","title":"Globals","text":"<p>The <code>Globals</code> class, and accompanying <code>PGlobals</code> pattern, can be used to share common variables across an isobar composition.</p> <p>For example:</p> <pre><code>#--------------------------------------------------------------------------------\n# Create a stream of events that will skip each note based on a \"density\"\n# global, with a key set by the \"key\" global.\n#--------------------------------------------------------------------------------\niso.Globals.set(\"density\", 0.5)\niso.Globals.set(\"key\", iso.Key(\"A\", \"minor\"))\n\np = iso.PDict({\n    \"degree\": iso.PSkip(0, iso.PGlobals(\"density\")),\n    \"key\": iso.PGlobals(\"key\")\n})\n</code></pre>"},{"location":"patterns/library/","title":"Pattern library reference","text":""},{"location":"patterns/library/#chance","title":"Chance","text":"<p>View source: chance.py</p> Class Function PStochasticPattern PStochasticPattern is the superclass of all chance-based patterns. PWhite White noise between <code>min</code> and <code>max</code>. PBrown Brownian noise. PCoin Coin toss, returning either 0 or 1 given some <code>probability</code>. PRandomWalk Random walk around list. PChoice Pick a random element from <code>values</code>, weighted by optional <code>weights</code>. PSample Pick multiple random elements from <code>values</code>, weighted by optional <code>weights</code>, PShuffle Shuffled list. PShuffleInput Every <code>n</code> steps, take <code>n</code> values from <code>pattern</code> and reorder. PSkip Skip events with some probability, 1 - <code>play</code>. PFlipFlop flip a binary bit with some probability. PSwitchOne Capture <code>length</code> input values; loop, repeatedly switching two adjacent values. PRandomExponential Random uniform on exponential curve between <code>min</code> and <code>max</code>, PRandomImpulseSequence Random sequence of impulses with probability <code>probability</code>."},{"location":"patterns/library/#core","title":"Core","text":"<p>View source: core.py</p> Class Function Pattern Abstract superclass of all pattern generators. PConstant Returns a fixed value. PRef Contains a reference to another pattern, which can be replaced dynamically. PFunc Returns the value generated by a function. PArrayIndex Request a specified index from an array. PDict Construct a pattern from a dict of arrays, or an array of dicts. PDictKey Request a specified key from a dictionary. PConcatenate Concatenate the output of multiple sequences. PAbs Absolute value of <code>input</code> PInt Integer value of <code>input</code> PAdd Add elements of two patterns (shorthand: patternA + patternB) PSub Subtract elements of two patterns (shorthand: patternA - patternB) PMul Multiply elements of two patterns (shorthand: patternA * patternB) PDiv Divide elements of two patterns (shorthand: patternA / patternB) PFloorDiv Integer division (shorthand: patternA // patternB) PMod Modulo elements of two patterns (shorthand: patternA % patternB) PPow One pattern to the power of another (shorthand: patternA ** patternB) PLShift Binary left-shift (shorthand: patternA &lt;&lt; patternB) PRShift Binary right-shift (shorthand: patternA &lt;&lt; patternB) PEqual Return 1 if a == b, 0 otherwise (shorthand: patternA == patternB) PNotEqual Return 1 if a != b, 0 otherwise (shorthand: patternA != patternB) PGreaterThan Return 1 if a &gt; b, 0 otherwise (shorthand: patternA &gt; patternB) PGreaterThanOrEqual Return 1 if a &gt;= b, 0 otherwise (shorthand: patternA &gt;= patternB) PLessThan Return 1 if a &lt; b, 0 otherwise (shorthand: patternA &lt; patternB) PLessThanOrEqual Return 1 if a &lt;= b, 0 otherwise (shorthand: patternA &lt;= patternB) PAnd Return True if a and b, False otherwise (shorthand: patternA &amp; patternB)"},{"location":"patterns/library/#fade","title":"Fade","text":"<p>View source: fade.py</p> Class Function PFadeNotewise Fade a pattern in/out by introducing notes at a gradual rate. PFadeNotewiseRandom Fade a pattern in/out by gradually introducing random notes."},{"location":"patterns/library/#lsystem","title":"Lsystem","text":"<p>View source: lsystem.py</p> Class Function PLSystem integer sequence derived from Lindenmayer systems"},{"location":"patterns/library/#markov","title":"Markov","text":"<p>View source: markov.py</p> Class Function PMarkov First-order Markov chain generator. MarkovLearner Learn a Markovian sequence by sequentially registering new values MarkovGrapher Helper class to graph the structure of a Markov object."},{"location":"patterns/library/#midi","title":"Midi","text":"<p>View source: midi.py</p> Class Function"},{"location":"patterns/library/#oscillator","title":"Oscillator","text":"<p>View source: oscillator.py</p> Class Function PTri Generates a triangle waveform of period <code>length</code>. PSaw Generates a sawtooth waveform."},{"location":"patterns/library/#scalar","title":"Scalar","text":"<p>View source: scalar.py</p> Class Function PChanged Outputs a 1 if the value of the input pattern has changed, PDiff Outputs the difference between the current and previous values of an input pattern PSkipIf If <code>skip</code> is false, returns <code>input</code>; otherwise, returns None. PNormalise Adaptively normalise <code>input</code> to [0..1] over a linear scale. PMap Apply an arbitrary function to an input pattern. PMapEnumerated Apply arbitrary function to input, passing a counter. PScaleLinLin Map <code>input</code> from linear range [a,b] to linear range [c,d]. PScaleLinExp Map <code>input</code> from linear range [a,b] to exponential range [c,d]. PRound Round <code>input</code> to N decimal places. PScalar Reduce tuples and lists into single scalar values, PWrap Wrap input note values within , . PIndexOf Find index of items from <code>pattern</code> in"},{"location":"patterns/library/#sequence","title":"Sequence","text":"<p>View source: sequence.py</p> Class Function PSequence Sequence of values based on an array PSeries Arithmetic series, beginning at <code>start</code>, increment by <code>step</code> PRange Similar to PSeries, but specify a max/step value. PGeom Geometric series, beginning at <code>start</code>, multiplied by <code>step</code> PImpulse Outputs a 1 every  events, otherwise 0. PLoop Repeats a finite <code>pattern</code> for <code>n</code> repeats. PPingPong Ping-pong input pattern back and forth N times. PCreep Loop <code>length</code>-note segment, progressing <code>creep</code> notes after <code>repeats</code> repeats. PStutter Play each note of <code>pattern</code> <code>count</code> times. PSubsequence Returns a finite subsequence of an input pattern. PReverse Reverses a finite sequence. PReset Resets <code>pattern</code> whenever <code>trigger</code> is true PCounter Increments a counter by 1 for each zero-crossing in <code>trigger</code>. PCollapse Skip over any rests in <code>input</code> PNoRepeats Skip over repeated values in <code>input</code> PPad Pad <code>pattern</code> with rests until it reaches length <code>length</code>. PPadToMultiple Pad <code>pattern</code> with rests until its length is divisible by <code>multiple</code>. PArpeggiator Arpeggiator. PEuclidean Generate Euclidean rhythms. PPermut Generate every permutation of <code>count</code> input items. PPatternGeneratorAction Each time its pattern is exhausted, request a new pattern by calling . PSequenceAction Iterate over an array, perform a function, and repeat."},{"location":"patterns/library/#static","title":"Static","text":"<p>View source: static.py</p> Class Function Globals The Globals class encapsulates a namespace of global variables that can be accessed PGlobals  Static global value identified by a string. PCurrentTime Returns the position (in beats) of the current timeline."},{"location":"patterns/library/#tonal","title":"Tonal","text":"<p>View source: tonal.py</p> Class Function PDegree Map scale index  to MIDI notes in . PFilterByKey Filter notes based on their presence in . PNearestNoteInKey Return the nearest note in . PMidiNoteToFrequency Map MIDI note to frequency value. PMidiSemitonesToFrequencyRatio Map a MIDI offet in semitones to a frequency ratio."},{"location":"patterns/library/#warp","title":"Warp","text":"<p>View source: warp.py</p> Class Function PWarp Requests a new target warp value from <code>pattern</code> every <code>length</code> beats PWSine Sinosoidal warp, period <code>length</code> beats, amplitude +/-. PWRallantando Exponential deceleration to  times the current tempo over <code>length</code> beats."},{"location":"patterns/chance/","title":"Chance","text":"<ul> <li>PStochasticPattern: PStochasticPattern is the superclass of all chance-based patterns.</li> <li>PWhite: White noise between <code>min</code> and <code>max</code>.</li> <li>PBrown: Brownian noise.</li> <li>PCoin: Coin toss, returning either 0 or 1 given some <code>probability</code>.</li> <li>PRandomWalk: Random walk around list.</li> <li>PChoice: Pick a random element from <code>values</code>, weighted by optional <code>weights</code>.</li> <li>PSample: Pick multiple random elements from <code>values</code>, weighted by optional <code>weights</code>,</li> <li>PShuffle: Shuffled list.</li> <li>PShuffleInput: Every <code>n</code> steps, take <code>n</code> values from <code>pattern</code> and reorder.</li> <li>PSkip: Skip events with some probability, 1 - <code>play</code>.</li> <li>PFlipFlop: flip a binary bit with some probability.</li> <li>PSwitchOne: Capture <code>length</code> input values; loop, repeatedly switching two adjacent values.</li> <li>PRandomExponential: Random uniform on exponential curve between <code>min</code> and <code>max</code>,</li> <li>PRandomImpulseSequence: Random sequence of impulses with probability <code>probability</code>.</li> </ul>"},{"location":"patterns/chance/pbrown/","title":"Pattern: PBrown","text":"<p>Brownian noise.</p> <p>Output begins at <code>initial_value</code>, and steps up/down by uniform random values from [-<code>step</code>, <code>step</code>] inclusive. If step is a float, the output is a float pattern. If step is an int, the output is an int pattern, with min &lt;= values &lt;= max.</p>"},{"location":"patterns/chance/pbrown/#arguments","title":"Arguments","text":"<p><code>initial_value (float or int)</code>: Initial value</p> <p><code>step (float or int)</code>: Maximum value to increase or decrease by each step</p> <p><code>min (float or int)</code>: Minimum permitted value</p> <p><code>min (float or int)</code>: Maximum permitted value</p>"},{"location":"patterns/chance/pchoice/","title":"Pattern: PChoice","text":"<p>Pick a random element from <code>values</code>, weighted by optional <code>weights</code>.</p> <p><code>weights</code> and <code>values</code> must be the same length. weights do not need to be normalised.</p>"},{"location":"patterns/chance/pchoice/#arguments","title":"Arguments","text":"<p><code>values</code>: A list of values</p> <p><code>weights</code>: An optional list of weights, of the same length as values</p>"},{"location":"patterns/chance/pchoice/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PChoice([ 0, 1, 10, 11 ])\n&gt;&gt;&gt; p.nextn(16)\n[11, 1, 0, 10, 1, 11, 1, 0, 11, 1, 11, 1, 1, 11, 11, 1]\n&gt;&gt;&gt; p = PChoice([ 1, 11, 111 ], [ 8, 2, 1 ])\n&gt;&gt;&gt; p.nextn(16)\n[111, 1, 1, 111, 1, 1, 1, 1, 1, 1, 1, 11, 1, 1, 1, 1]\n</code></pre>"},{"location":"patterns/chance/pcoin/","title":"Pattern: PCoin","text":"<p>Coin toss, returning either 0 or 1 given some <code>probability</code>.</p> <p><code>probability</code> is the chance of returning 1, and must be between [0, 1]. This is a convenience pattern which could also be written as <code>PWhite(0, 1) &lt; probability</code></p>"},{"location":"patterns/chance/pcoin/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PCoin(0.75).nextn(16)\n[1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1]\n</code></pre>"},{"location":"patterns/chance/pflipflop/","title":"Pattern: PFlipFlop","text":"<p>flip a binary bit with some probability.</p> <p> is initial value (0 or 1)  is chance of switching from 0-&gt;1  is chance of switching from 1-&gt;0"},{"location":"patterns/chance/pflipflop/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PFlipFlop(0, 0.9, 0.5)\n&gt;&gt;&gt; p.nextn(16)\n[1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1]\n</code></pre>"},{"location":"patterns/chance/prandomexponential/","title":"Pattern: PRandomExponential","text":"<p>Random uniform on exponential curve between <code>min</code> and <code>max</code>,</p> <p>both of which must be strictly positive. If values are given as floats, output values are also floats &lt; max. If values are ints, output values are ints &lt;= max (as random.randint)</p>"},{"location":"patterns/chance/prandomexponential/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PRandomExponential(1, 100).nextn(16)\n[3, 2, 12, 1, 6, 13, 14, 25, 78, 78, 4, 49, 5, 97, 69, 12]\n&gt;&gt;&gt; PRandomExponential(1.0, 100.0).nextn(16)\n[54.84880471711992, 89.53150541306805, 2.4077905492103318, ... ]\n</code></pre>"},{"location":"patterns/chance/prandomimpulsesequence/","title":"Pattern: PRandomImpulseSequence","text":"<p>Random sequence of impulses with probability <code>probability</code>.</p>"},{"location":"patterns/chance/prandomimpulsesequence/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PRandomImpulseSequence(0.3, 16).nextn(16)\n[...]\n</code></pre>"},{"location":"patterns/chance/prandomwalk/","title":"Pattern: PRandomWalk","text":"<p>Random walk around list.</p> <p>Jumps between <code>min</code> and <code>max</code> steps inclusive.</p>"},{"location":"patterns/chance/prandomwalk/#arguments","title":"Arguments","text":"<p><code>values (list)</code>: Array of values to walk around</p> <p><code>min (int)</code>: Minimum number of steps to move</p> <p><code>max (int)</code>: Maximum number of steps to move</p> <p><code>wrap (bool)</code>: Whether to wrap around the start/end of the array</p>"},{"location":"patterns/chance/prandomwalk/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PRandomWalk([ 0, 2, 5, 8, 11 ], min=1, max=2).nextn(16)\n[8, 11, 0, 8, 0, 11, 2, 11, 2, 0, 5, 8, 11, 8, 5, 8]\n</code></pre>"},{"location":"patterns/chance/psample/","title":"Pattern: PSample","text":"<p>Pick multiple random elements from <code>values</code>, weighted by optional <code>weights</code>,</p> <p>without replacement. Each return value is a list. <code>weights</code> and <code>values</code> must be the same length. weights do not need to be normalised.</p>"},{"location":"patterns/chance/psample/#arguments","title":"Arguments","text":"<p><code>values</code>: A list of values</p> <p><code>weights</code>: An optional list of weights, of the same length as values</p>"},{"location":"patterns/chance/psample/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PSample([1, 2, 3], count=2, weights=[1, 2, 3])\n&gt;&gt;&gt; p.nextn(16)\n[[3, 2], [2, 3], [3, 2], [3, 1], [2, 3], [3, 2], [2, 3], [3, 1], [3, 2], [3, 2], [2, 3],\n[3, 2], [2, 1], [2, 3], [3, 2], [2, 3]]\n</code></pre>"},{"location":"patterns/chance/pshuffle/","title":"Pattern: PShuffle","text":"<p>Shuffled list.</p>"},{"location":"patterns/chance/pshuffle/#arguments","title":"Arguments","text":"<p><code>values (list)</code>: List of values</p> <p><code>repeats (int)</code>: Number of times to re-shuffle and iterate</p>"},{"location":"patterns/chance/pshuffle/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PShuffle([ 1, 2, 3 ])\n&gt;&gt;&gt; p.nextn(16)\n[1, 3, 2, 3, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 3, 1]\n</code></pre>"},{"location":"patterns/chance/pshuffleinput/","title":"Pattern: PShuffleInput","text":"<p>Every <code>n</code> steps, take <code>n</code> values from <code>pattern</code> and reorder.</p>"},{"location":"patterns/chance/pshuffleinput/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PShuffleInput(PSeries(0, 1), 4)\n&gt;&gt;&gt; p.nextn(16)\n</code></pre>"},{"location":"patterns/chance/pskip/","title":"Pattern: PSkip","text":"<p>Skip events with some probability, 1 - <code>play</code>.</p> <p>Set  to True to skip events regularly."},{"location":"patterns/chance/pstochasticpattern/","title":"Pattern: PStochasticPattern","text":"<p>PStochasticPattern is the superclass of all chance-based patterns.</p> <p>It contains its own random number generator and state, so that it can be seeded independently of other RNG processes in the application. When it is created, a random seed is generated and stored. When reset() is called, the pattern's RNG is re-seeded with this same seed, allow it to rewind to the beginning of its random pattern.</p>"},{"location":"patterns/chance/pswitchone/","title":"Pattern: PSwitchOne","text":"<p>Capture <code>length</code> input values; loop, repeatedly switching two adjacent values.</p>"},{"location":"patterns/chance/pwhite/","title":"Pattern: PWhite","text":"<p>White noise between <code>min</code> and <code>max</code>.</p> <p>If values are given as floats, output values are also floats &lt; max. If values are ints, output values are ints &lt;= max (as random.randint)</p>"},{"location":"patterns/chance/pwhite/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PWhite(0, 10).nextn(16)\n[8, 10, 8, 1, 7, 3, 1, 9, 9, 3, 2, 10, 7, 5, 10, 4]\n&gt;&gt;&gt; PWhite(0.0, 10.0).nextn(16)\n[3.6747936220022082, 0.61313530428271923, 9.1515368696591555, ... 6.2963694390145974 ]\n</code></pre>"},{"location":"patterns/core/","title":"Core","text":"<ul> <li>Pattern: Abstract superclass of all pattern generators.</li> <li>PConstant: Returns a fixed value.</li> <li>PRef: Contains a reference to another pattern, which can be replaced dynamically.</li> <li>PFunc: Returns the value generated by a function.</li> <li>PArrayIndex: Request a specified index from an array.</li> <li>PDict: Construct a pattern from a dict of arrays, or an array of dicts.</li> <li>PDictKey: Request a specified key from a dictionary.</li> <li>PConcatenate: Concatenate the output of multiple sequences.</li> <li>PAbs: Absolute value of <code>input</code></li> <li>PInt: Integer value of <code>input</code></li> <li>PAdd: Add elements of two patterns (shorthand: patternA + patternB)</li> <li>PSub: Subtract elements of two patterns (shorthand: patternA - patternB)</li> <li>PMul: Multiply elements of two patterns (shorthand: patternA * patternB)</li> <li>PDiv: Divide elements of two patterns (shorthand: patternA / patternB)</li> <li>PFloorDiv: Integer division (shorthand: patternA // patternB)</li> <li>PMod: Modulo elements of two patterns (shorthand: patternA % patternB)</li> <li>PPow: One pattern to the power of another (shorthand: patternA ** patternB)</li> <li>PLShift: Binary left-shift (shorthand: patternA &lt;&lt; patternB)</li> <li>PRShift: Binary right-shift (shorthand: patternA &lt;&lt; patternB)</li> <li>PEqual: Return 1 if a == b, 0 otherwise (shorthand: patternA == patternB)</li> <li>PNotEqual: Return 1 if a != b, 0 otherwise (shorthand: patternA != patternB)</li> <li>PGreaterThan: Return 1 if a &gt; b, 0 otherwise (shorthand: patternA &gt; patternB)</li> <li>PGreaterThanOrEqual: Return 1 if a &gt;= b, 0 otherwise (shorthand: patternA &gt;= patternB)</li> <li>PLessThan: Return 1 if a &lt; b, 0 otherwise (shorthand: patternA &lt; patternB)</li> <li>PLessThanOrEqual: Return 1 if a &lt;= b, 0 otherwise (shorthand: patternA &lt;= patternB)</li> <li>PAnd: Return True if a and b, False otherwise (shorthand: patternA &amp; patternB)</li> </ul>"},{"location":"patterns/core/pabs/","title":"Pattern: PAbs","text":"<p>Absolute value of <code>input</code></p>"},{"location":"patterns/core/padd/","title":"Pattern: PAdd","text":"<p>Add elements of two patterns (shorthand: patternA + patternB)</p>"},{"location":"patterns/core/pand/","title":"Pattern: PAnd","text":"<p>Return True if a and b, False otherwise (shorthand: patternA &amp; patternB)</p>"},{"location":"patterns/core/parrayindex/","title":"Pattern: PArrayIndex","text":"<p>Request a specified index from an array.</p> <p>If the item is a Pattern, the next value from that pattern is returned.</p>"},{"location":"patterns/core/pattern/","title":"Pattern: Pattern","text":"<p>Abstract superclass of all pattern generators.</p> <p>Patterns are at the core of isobar. A Pattern implements the iterator protocol, representing a sequence of values which are iteratively returned by the next() method. A pattern may be finite, after which point it raises a StopIteration exception. Call reset() to return a pattern to its initial state. Patterns can be subject to standard arithmetic operators as expected.</p>"},{"location":"patterns/core/pconcatenate/","title":"Pattern: PConcatenate","text":"<p>Concatenate the output of multiple sequences.</p>"},{"location":"patterns/core/pconcatenate/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PConcatenate([ PSequence([ 1, 2, 3 ], 2), PSequence([ 9, 8, 7 ], 2) ]).nextn(16)\n[1, 2, 3, 1, 2, 3, 9, 8, 7, 9, 8, 7]\n</code></pre>"},{"location":"patterns/core/pconstant/","title":"Pattern: PConstant","text":"<p>Returns a fixed value.</p>"},{"location":"patterns/core/pconstant/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PConstant(4)\n&gt;&gt;&gt; p.nextn(16)\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]\n</code></pre>"},{"location":"patterns/core/pdict/","title":"Pattern: PDict","text":"<p>Construct a pattern from a dict of arrays, or an array of dicts.</p> <p>The below are equivalent: PDict([ { \"note\" : 60, \"velocity\" : 64 }, { \"note\" : 67, \"velocity\" : 32 }, ... ]) PDict({ \"note\" : [ 60, 67 ], \"velocity\" : [ 64, 32 ]}) Thanks to Dan Stowell http://www.mcld.co.uk/</p>"},{"location":"patterns/core/pdictkey/","title":"Pattern: PDictKey","text":"<p>Request a specified key from a dictionary.</p>"},{"location":"patterns/core/pdiv/","title":"Pattern: PDiv","text":"<p>Divide elements of two patterns (shorthand: patternA / patternB)</p>"},{"location":"patterns/core/pequal/","title":"Pattern: PEqual","text":"<p>Return 1 if a == b, 0 otherwise (shorthand: patternA == patternB)</p>"},{"location":"patterns/core/pfloordiv/","title":"Pattern: PFloorDiv","text":"<p>Integer division (shorthand: patternA // patternB)</p>"},{"location":"patterns/core/pfunc/","title":"Pattern: PFunc","text":"<p>Returns the value generated by a function.</p> <p>Useful to incorporate additional logic into a pattern.</p>"},{"location":"patterns/core/pfunc/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; seconds = PFunc(lambda: datetime.datetime.now().second)\n&gt;&gt;&gt; p.nextn(16)\n[19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19]\n</code></pre>"},{"location":"patterns/core/pgreaterthan/","title":"Pattern: PGreaterThan","text":"<p>Return 1 if a &gt; b, 0 otherwise (shorthand: patternA &gt; patternB)</p>"},{"location":"patterns/core/pgreaterthanorequal/","title":"Pattern: PGreaterThanOrEqual","text":"<p>Return 1 if a &gt;= b, 0 otherwise (shorthand: patternA &gt;= patternB)</p>"},{"location":"patterns/core/pint/","title":"Pattern: PInt","text":"<p>Integer value of <code>input</code></p>"},{"location":"patterns/core/plessthan/","title":"Pattern: PLessThan","text":"<p>Return 1 if a &lt; b, 0 otherwise (shorthand: patternA &lt; patternB)</p>"},{"location":"patterns/core/plessthanorequal/","title":"Pattern: PLessThanOrEqual","text":"<p>Return 1 if a &lt;= b, 0 otherwise (shorthand: patternA &lt;= patternB)</p>"},{"location":"patterns/core/plshift/","title":"Pattern: PLShift","text":"<p>Binary left-shift (shorthand: patternA &lt;&lt; patternB)</p>"},{"location":"patterns/core/pmod/","title":"Pattern: PMod","text":"<p>Modulo elements of two patterns (shorthand: patternA % patternB)</p>"},{"location":"patterns/core/pmul/","title":"Pattern: PMul","text":"<p>Multiply elements of two patterns (shorthand: patternA * patternB)</p>"},{"location":"patterns/core/pnotequal/","title":"Pattern: PNotEqual","text":"<p>Return 1 if a != b, 0 otherwise (shorthand: patternA != patternB)</p>"},{"location":"patterns/core/ppow/","title":"Pattern: PPow","text":"<p>One pattern to the power of another (shorthand: patternA ** patternB)</p>"},{"location":"patterns/core/pref/","title":"Pattern: PRef","text":"<p>Contains a reference to another pattern, which can be replaced dynamically.</p> <p>Returns the next value of the pattern contained. Useful to change an inner pattern in real time.</p>"},{"location":"patterns/core/prshift/","title":"Pattern: PRShift","text":"<p>Binary right-shift (shorthand: patternA &lt;&lt; patternB)</p>"},{"location":"patterns/core/psub/","title":"Pattern: PSub","text":"<p>Subtract elements of two patterns (shorthand: patternA - patternB)</p>"},{"location":"patterns/fade/","title":"Fade","text":"<ul> <li>PFadeNotewise: Fade a pattern in/out by introducing notes at a gradual rate.</li> <li>PFadeNotewiseRandom: Fade a pattern in/out by gradually introducing random notes.</li> </ul>"},{"location":"patterns/fade/pfadenotewise/","title":"Pattern: PFadeNotewise","text":"<p>Fade a pattern in/out by introducing notes at a gradual rate.</p>"},{"location":"patterns/fade/pfadenotewiserandom/","title":"Pattern: PFadeNotewiseRandom","text":"<p>Fade a pattern in/out by gradually introducing random notes.</p>"},{"location":"patterns/lsystem/","title":"Lsystem","text":"<ul> <li>PLSystem: integer sequence derived from Lindenmayer systems</li> </ul>"},{"location":"patterns/lsystem/plsystem/","title":"Pattern: PLSystem","text":"<p>integer sequence derived from Lindenmayer systems</p>"},{"location":"patterns/markov/","title":"Markov","text":"<ul> <li>PMarkov: First-order Markov chain generator.</li> <li>MarkovLearner: Learn a Markovian sequence by sequentially registering new values</li> <li>MarkovGrapher: Helper class to graph the structure of a Markov object.</li> </ul>"},{"location":"patterns/markov/markovgrapher/","title":"Pattern: MarkovGrapher","text":"<p>Helper class to graph the structure of a Markov object.</p> <p>Requires graphviz (pip install graphviz).</p>"},{"location":"patterns/markov/markovlearner/","title":"Pattern: MarkovLearner","text":"<p>Learn a Markovian sequence by sequentially registering new values</p> <p>and building up a dynamic node graph.</p>"},{"location":"patterns/markov/pmarkov/","title":"Pattern: PMarkov","text":"<p>First-order Markov chain generator.</p>"},{"location":"patterns/markov/pmarkov/#arguments","title":"Arguments","text":"<p>`* an ordered sequence of notes (which will be used to infer the</p> <p>`probabilities of transitioning between notes), or</p> <p><code>* a dictionary of the form { 1</code>: [ 2, 2, 3 ], 2 : [ 3 ], 3 : [ 1, 2 ] },</p> <p>`where values determine the probability of transitioning from A to B</p> <p>`based on the number of occurrences of B in the list with key A.</p>"},{"location":"patterns/midi/","title":"Midi","text":""},{"location":"patterns/oscillator/","title":"Oscillator","text":"<ul> <li>PTri: Generates a triangle waveform of period <code>length</code>.</li> <li>PSaw: Generates a sawtooth waveform.</li> </ul>"},{"location":"patterns/oscillator/psaw/","title":"Pattern: PSaw","text":"<p>Generates a sawtooth waveform.</p>"},{"location":"patterns/oscillator/psaw/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PTri(10)\n&gt;&gt;&gt; p.nextn(10)\n[0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 0.8, 0.6, 0.4, 0.2]\n</code></pre>"},{"location":"patterns/oscillator/ptri/","title":"Pattern: PTri","text":"<p>Generates a triangle waveform of period <code>length</code>.</p>"},{"location":"patterns/oscillator/ptri/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PTri(10)\n&gt;&gt;&gt; p.nextn(10)\n[0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 0.8, 0.6, 0.4, 0.2]\n</code></pre>"},{"location":"patterns/scalar/","title":"Scalar","text":"<ul> <li>PChanged: Outputs a 1 if the value of the input pattern has changed,</li> <li>PDiff: Outputs the difference between the current and previous values of an input pattern</li> <li>PSkipIf: If <code>skip</code> is false, returns <code>input</code>; otherwise, returns None.</li> <li>PNormalise: Adaptively normalise <code>input</code> to [0..1] over a linear scale.</li> <li>PMap: Apply an arbitrary function to an input pattern.</li> <li>PMapEnumerated: Apply arbitrary function to input, passing a counter.</li> <li>PScaleLinLin: Map <code>input</code> from linear range [a,b] to linear range [c,d].</li> <li>PScaleLinExp: Map <code>input</code> from linear range [a,b] to exponential range [c,d].</li> <li>PRound: Round <code>input</code> to N decimal places.</li> <li>PScalar: Reduce tuples and lists into single scalar values,</li> <li>PWrap: Wrap input note values within , . <li>PIndexOf: Find index of items from <code>pattern</code> in"},{"location":"patterns/scalar/pchanged/","title":"Pattern: PChanged","text":"<p>Outputs a 1 if the value of the input pattern has changed,</p> <p>or 0 otherwise.</p>"},{"location":"patterns/scalar/pchanged/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; a = PSequence([1, 0, 1, 2, 2, 2, 1, 0, 0, 1], repeats=1)\n&gt;&gt;&gt; b = PChanged(a)\n&gt;&gt;&gt; b.all()\n[1, 1, 1, 0, 0, 1, 1, 0, 1]\n</code></pre>"},{"location":"patterns/scalar/pdiff/","title":"Pattern: PDiff","text":"<p>Outputs the difference between the current and previous values of an input pattern</p> <p>If the current or next value are None, a value of None will be output. The length of the output pattern is always 1 less than the length of the input.</p>"},{"location":"patterns/scalar/pdiff/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; a = PSequence([1, 0, 1, 2, 2, 2, 1, 0, 0, 1], repeats=1)\n&gt;&gt;&gt; b = PDiff(a)\n&gt;&gt;&gt; b.all()\n[-1, 1, 1, 0, 0, -1, -1, 0, 1]\n</code></pre>"},{"location":"patterns/scalar/pindexof/","title":"Pattern: PIndexOf","text":"<p>Find index of items from <code>pattern</code> in"},{"location":"patterns/scalar/pindexof/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PIndexOf([ chr(ord(\"a\") + n) for n in range(26) ], PSeq(\"isobar\"))\n&gt;&gt;&gt; p.nextn(16)\n[8, 18, 14, 1, 0, 17, 8, 18, 14, 1, 0, 17, 8, 18, 14, 1]\n</code></pre>"},{"location":"patterns/scalar/pmap/","title":"Pattern: PMap","text":"<p>Apply an arbitrary function to an input pattern.</p> <p>Will pass any additional arguments, which can also be patterns. Instances of None in the input stream will be passed through to the function as normal.</p>"},{"location":"patterns/scalar/pmap/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PMap(PSeries(), lambda value: value * value).nextn(16)\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 144, 169, 196, 225]\n&gt;&gt;&gt; PMap(PSeries(), pow, PSeries()).nextn(16)\n[1, 1, 4, 27, 256, 3125, 46656, 823543, 16777216, 387420489, 10000000000, ... ]\n</code></pre>"},{"location":"patterns/scalar/pmapenumerated/","title":"Pattern: PMapEnumerated","text":"<p>Apply arbitrary function to input, passing a counter.</p>"},{"location":"patterns/scalar/pmapenumerated/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; PMapEnumerated(PSeq([ 1, 11, 111 ]), lambda n, value: n * value).nextn(16)\n[0, 11, 222, 3, 44, 555, 6, 77, 888, 9, 110, 1221, 12, 143, 1554, 15]\n</code></pre>"},{"location":"patterns/scalar/pnormalise/","title":"Pattern: PNormalise","text":"<p>Adaptively normalise <code>input</code> to [0..1] over a linear scale.</p> <p>Use maximum and minimum values found in history. If you know the output range ahead of time, use <code>PScaleLinLin</code>.</p>"},{"location":"patterns/scalar/pround/","title":"Pattern: PRound","text":"<p>Round <code>input</code> to N decimal places.</p>"},{"location":"patterns/scalar/pround/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PRound(PWhite(0.0, 10.0))\n&gt;&gt;&gt; p.nextn(16)\n[6, 8, 6, 0, 7, 6, 6, 4, 7, 7, 8, 7, 6, 8, 8, 4]\n</code></pre>"},{"location":"patterns/scalar/pscalar/","title":"Pattern: PScalar","text":"<p>Reduce tuples and lists into single scalar values,</p> <p>either by taking the mean or the first value. Empty lists are reduced to None.</p>"},{"location":"patterns/scalar/pscalar/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PScalar(PSequence([ 1, (2, 3), (4, 5, 6), (), 7 ], 1)\n&gt;&gt;&gt; p.all())\n[1, 2.5, 5, None, 7]\n</code></pre>"},{"location":"patterns/scalar/pscalelinexp/","title":"Pattern: PScaleLinExp","text":"<p>Map <code>input</code> from linear range [a,b] to exponential range [c,d].</p>"},{"location":"patterns/scalar/pscalelinexp/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PScaleLinExp(PWhite(0.0, 1.0), 0, 1, 40, 20000)\n&gt;&gt;&gt; p.nextn(16)\n[946.888, 282.944, 2343.145, 634.637, 218.844, 19687.330, 4457.627, 172.419, 934.666, ... 46.697 ]\n</code></pre>"},{"location":"patterns/scalar/pscalelinlin/","title":"Pattern: PScaleLinLin","text":"<p>Map <code>input</code> from linear range [a,b] to linear range [c,d].</p>"},{"location":"patterns/scalar/pscalelinlin/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PScaleLinLin(PWhite(), 0, 1, -50, 50)\n&gt;&gt;&gt; p.nextn(16)\n[-34.434991496625955, -33.38823791706497, 42.153457333940267, 16.692545937573783, ... -48.850511242044604 ]\n</code></pre>"},{"location":"patterns/scalar/pskipif/","title":"Pattern: PSkipIf","text":"<p>If <code>skip</code> is false, returns <code>input</code>; otherwise, returns None.</p>"},{"location":"patterns/scalar/pwrap/","title":"Pattern: PWrap","text":"<p>Wrap input note values within , ."},{"location":"patterns/scalar/pwrap/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PWrap(PSeries(5, 3), 0, 10)\n&gt;&gt;&gt; p.nextn(16)\n[5, 8, 1, 4, 7, 0, 3, 6, 9, 2, 5, 8, 1, 4, 7, 0]\n</code></pre>"},{"location":"patterns/sequence/","title":"Sequence","text":"<ul> <li>PSequence: Sequence of values based on an array</li> <li>PSeries: Arithmetic series, beginning at <code>start</code>, increment by <code>step</code></li> <li>PRange: Similar to PSeries, but specify a max/step value.</li> <li>PGeom: Geometric series, beginning at <code>start</code>, multiplied by <code>step</code></li> <li>PImpulse: Outputs a 1 every  events, otherwise 0. <li>PLoop: Repeats a finite <code>pattern</code> for <code>n</code> repeats.</li> <li>PPingPong: Ping-pong input pattern back and forth N times.</li> <li>PCreep: Loop <code>length</code>-note segment, progressing <code>creep</code> notes after <code>repeats</code> repeats.</li> <li>PStutter: Play each note of <code>pattern</code> <code>count</code> times.</li> <li>PSubsequence: Returns a finite subsequence of an input pattern.</li> <li>PReverse: Reverses a finite sequence.</li> <li>PReset: Resets <code>pattern</code> whenever <code>trigger</code> is true</li> <li>PCounter: Increments a counter by 1 for each zero-crossing in <code>trigger</code>.</li> <li>PCollapse: Skip over any rests in <code>input</code></li> <li>PNoRepeats: Skip over repeated values in <code>input</code></li> <li>PPad: Pad <code>pattern</code> with rests until it reaches length <code>length</code>.</li> <li>PPadToMultiple: Pad <code>pattern</code> with rests until its length is divisible by <code>multiple</code>.</li> <li>PArpeggiator: Arpeggiator.</li> <li>PEuclidean: Generate Euclidean rhythms.</li> <li>PPermut: Generate every permutation of <code>count</code> input items.</li> <li>PPatternGeneratorAction: Each time its pattern is exhausted, request a new pattern by calling . <li>PSequenceAction: Iterate over an array, perform a function, and repeat.</li>"},{"location":"patterns/sequence/parpeggiator/","title":"Pattern: PArpeggiator","text":"<p>Arpeggiator.</p> <p> can be one of: PArp.UP PArp.DOWN PArp.UPDOWN PArp.CONVERGE PArp.DIVERGE PArp.RANDOM"},{"location":"patterns/sequence/parpeggiator/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PLoop(PArpeggiator(Chord.major, PArpeggiator.CONVERGE))\n&gt;&gt;&gt; p.nextn(16)\n[0, 12, 4, 7, 0, 12, 4, 7, 0, 12, 4, 7, 0, 12, 4, 7]\n</code></pre>"},{"location":"patterns/sequence/pcollapse/","title":"Pattern: PCollapse","text":"<p>Skip over any rests in <code>input</code></p>"},{"location":"patterns/sequence/pcounter/","title":"Pattern: PCounter","text":"<p>Increments a counter by 1 for each zero-crossing in <code>trigger</code>.</p>"},{"location":"patterns/sequence/pcounter/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PCounter(PImpulse(4))\n&gt;&gt;&gt; p.nextn(16)\n[1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]\n</code></pre>"},{"location":"patterns/sequence/pcreep/","title":"Pattern: PCreep","text":"<p>Loop <code>length</code>-note segment, progressing <code>creep</code> notes after <code>repeats</code> repeats.</p>"},{"location":"patterns/sequence/pcreep/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PCreep(PSeries(), 3, 1, 2)\n&gt;&gt;&gt; p.nextn(16)\n[0, 1, 2, 0, 1, 2, 1, 2, 3, 1, 2, 3, 2, 3, 4, 2]\n</code></pre>"},{"location":"patterns/sequence/peuclidean/","title":"Pattern: PEuclidean","text":"<p>Generate Euclidean rhythms.</p> <p>Effectively tries to space  events out evenly over <code>length</code> beats. Events returned are either 1 or None (rest)"},{"location":"patterns/sequence/peuclidean/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PEuclidean(5, 8)\n&gt;&gt;&gt; p.nextn(8)\n[1, None, 1, 1, None, 1, 1, None]\n</code></pre>"},{"location":"patterns/sequence/pgeom/","title":"Pattern: PGeom","text":"<p>Geometric series, beginning at <code>start</code>, multiplied by <code>step</code></p>"},{"location":"patterns/sequence/pgeom/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PGeom(1, 2)\n&gt;&gt;&gt; p.nextn(16)\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768]\n</code></pre>"},{"location":"patterns/sequence/pimpulse/","title":"Pattern: PImpulse","text":"<p>Outputs a 1 every  events, otherwise 0."},{"location":"patterns/sequence/pimpulse/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PImpulse(4)\n&gt;&gt;&gt; p.nextn(16)\n[1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0]\n</code></pre>"},{"location":"patterns/sequence/ploop/","title":"Pattern: PLoop","text":"<p>Repeats a finite <code>pattern</code> for <code>n</code> repeats.</p> <p>Useful for pattern generators which don't natively loop. Input must be finite or results may vary.</p>"},{"location":"patterns/sequence/ploop/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PLoop(PSeq([ 1, 4, 9 ], 1))\n&gt;&gt;&gt; p.nextn(16)\n[1, 4, 9, 1, 4, 9, 1, 4, 9, 1, 4, 9, 1, 4, 9, 1]\n</code></pre>"},{"location":"patterns/sequence/pnorepeats/","title":"Pattern: PNoRepeats","text":"<p>Skip over repeated values in <code>input</code></p>"},{"location":"patterns/sequence/ppad/","title":"Pattern: PPad","text":"<p>Pad <code>pattern</code> with rests until it reaches length <code>length</code>.</p>"},{"location":"patterns/sequence/ppadtomultiple/","title":"Pattern: PPadToMultiple","text":"<p>Pad <code>pattern</code> with rests until its length is divisible by <code>multiple</code>.</p> <p>Enforces a minimum padding of <code>minimum_pad</code>. Useful to create patterns which occupy a whole number of bars.</p>"},{"location":"patterns/sequence/ppatterngeneratoraction/","title":"Pattern: PPatternGeneratorAction","text":"<p>Each time its pattern is exhausted, request a new pattern by calling ."},{"location":"patterns/sequence/ppatterngeneratoraction/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt;\n&gt;&gt;&gt;\n</code></pre>"},{"location":"patterns/sequence/ppermut/","title":"Pattern: PPermut","text":"<p>Generate every permutation of <code>count</code> input items.</p>"},{"location":"patterns/sequence/ppermut/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PPermut(PSeq([ 1, 11, 111, 1111 ]), 4)\n&gt;&gt;&gt; p.nextn(16)\n[1, 11, 111, 1111, 1, 11, 1111, 111, 1, 111, 11, 1111, 1, 111, 1111, 11]\n</code></pre>"},{"location":"patterns/sequence/ppingpong/","title":"Pattern: PPingPong","text":"<p>Ping-pong input pattern back and forth N times.</p>"},{"location":"patterns/sequence/ppingpong/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PPingPong(PSeq([ 1, 4, 9 ], 1), 10)\n&gt;&gt;&gt; p.nextn(16)\n[1, 4, 9, 4, 1, 4, 9, 4, 1, 4, 9, 4, 1, 4, 9, 4]\n</code></pre>"},{"location":"patterns/sequence/prange/","title":"Pattern: PRange","text":"<p>Similar to PSeries, but specify a max/step value.</p>"},{"location":"patterns/sequence/prange/#arguments","title":"Arguments","text":"<p><code>start (int or float)</code>: Start value</p> <p><code>end (int, float or Pattern)</code>: End value</p> <p><code>step (int, float or Pattern)</code>: Step value</p>"},{"location":"patterns/sequence/prange/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PRange(0, 20, 2)\n&gt;&gt;&gt; p.nextn(16)\n[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]\n</code></pre>"},{"location":"patterns/sequence/preset/","title":"Pattern: PReset","text":"<p>Resets <code>pattern</code> whenever <code>trigger</code> is true</p>"},{"location":"patterns/sequence/preset/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PReset(PSeries(0, 1), PImpulse(4))\n&gt;&gt;&gt; p.nextn(16)\n[0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n</code></pre>"},{"location":"patterns/sequence/preverse/","title":"Pattern: PReverse","text":"<p>Reverses a finite sequence.</p>"},{"location":"patterns/sequence/psequence/","title":"Pattern: PSequence","text":"<p>Sequence of values based on an array</p> <p>Takes an input list, and repeats the items in this list.</p>"},{"location":"patterns/sequence/psequence/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PSeq([ 1, 2, 3, 5 ])\n&gt;&gt;&gt; p.nextn(10)\n[1, 2, 3, 5, 1, 2, 3, 5, 1, 2, 3, 5, 1, 2, 3, 5]\n</code></pre>"},{"location":"patterns/sequence/psequenceaction/","title":"Pattern: PSequenceAction","text":"<p>Iterate over an array, perform a function, and repeat.</p>"},{"location":"patterns/sequence/psequenceaction/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt;\n&gt;&gt;&gt;\n</code></pre>"},{"location":"patterns/sequence/pseries/","title":"Pattern: PSeries","text":"<p>Arithmetic series, beginning at <code>start</code>, increment by <code>step</code></p>"},{"location":"patterns/sequence/pseries/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PSeries(3, 9)\n&gt;&gt;&gt; p.nextn(16)\n[3, 12, 21, 30, 39, 48, 57, 66, 75, 84, 93, 102, 111, 120, 129, 138]\n</code></pre>"},{"location":"patterns/sequence/pstutter/","title":"Pattern: PStutter","text":"<p>Play each note of <code>pattern</code> <code>count</code> times.</p> <p>Is really a more convenient way to do: PCreep(pattern, 1, 1, count)</p>"},{"location":"patterns/sequence/pstutter/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PStutter(PSeries(), 2)\n&gt;&gt;&gt; p.nextn(16)\n[0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]\n</code></pre>"},{"location":"patterns/sequence/psubsequence/","title":"Pattern: PSubsequence","text":"<p>Returns a finite subsequence of an input pattern.</p>"},{"location":"patterns/sequence/psubsequence/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PSubsequence(PSeries(0, 1), 2, 4)\n&gt;&gt;&gt; p.nextn(16)\n[2, 3, 4, 5]\n</code></pre>"},{"location":"patterns/static/","title":"Static","text":"<ul> <li>Globals: The Globals class encapsulates a namespace of global variables that can be accessed</li> <li>PGlobals : Static global value identified by a string.</li> <li>PCurrentTime: Returns the position (in beats) of the current timeline.</li> </ul>"},{"location":"patterns/static/globals/","title":"Pattern: Globals","text":"<p>The Globals class encapsulates a namespace of global variables that can be accessed</p> <p>throughout isobar. This is particularly useful to alter parameters shared across the composition, which can then be accessed in patterns using the PGlobals class.</p>"},{"location":"patterns/static/pcurrenttime/","title":"Pattern: PCurrentTime","text":"<p>Returns the position (in beats) of the current timeline.</p>"},{"location":"patterns/static/pglobals%20/","title":"Pattern: PGlobals","text":"<p>Static global value identified by a string.</p>"},{"location":"patterns/tonal/","title":"Tonal","text":"<ul> <li>PDegree: Map scale index  to MIDI notes in . <li>PFilterByKey: Filter notes based on their presence in . <li>PNearestNoteInKey: Return the nearest note in . <li>PMidiNoteToFrequency: Map MIDI note to frequency value.</li> <li>PMidiSemitonesToFrequencyRatio: Map a MIDI offet in semitones to a frequency ratio.</li>"},{"location":"patterns/tonal/pdegree/","title":"Pattern: PDegree","text":"<p>Map scale index  to MIDI notes in ."},{"location":"patterns/tonal/pdegree/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PDegree(PSeries(0, 1), Scale.major)\n&gt;&gt;&gt; p.nextn(16)\n[0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17, 19, 21, 23, 24, 26]\n</code></pre>"},{"location":"patterns/tonal/pfilterbykey/","title":"Pattern: PFilterByKey","text":"<p>Filter notes based on their presence in . <p>IF a note is not in , None is returned instead. To compress the output and remove rests, use PCollapse."},{"location":"patterns/tonal/pfilterbykey/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PFilterByKey(PSeries(0, 1), Key(\"C\", \"major\"))\n&gt;&gt;&gt; p.nextn(16)\n[0, None, 2, None, 4, 5, None, 7, None, 9, None, 11, 12, None, 14, None]\n</code></pre>"},{"location":"patterns/tonal/pmidinotetofrequency/","title":"Pattern: PMidiNoteToFrequency","text":"<p>Map MIDI note to frequency value.</p>"},{"location":"patterns/tonal/pmidisemitonestofrequencyratio/","title":"Pattern: PMidiSemitonesToFrequencyRatio","text":"<p>Map a MIDI offet in semitones to a frequency ratio.</p> <p>e.g. 0 -&gt; 1.0 12 -&gt; 2.0 7 -&gt; 1.5</p>"},{"location":"patterns/tonal/pnearestnoteinkey/","title":"Pattern: PNearestNoteInKey","text":"<p>Return the nearest note in ."},{"location":"patterns/tonal/pnearestnoteinkey/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PNearestNoteKey(PSeries(0, 1), Key(\"C\", \"major\"))\n&gt;&gt;&gt; p.nextn(16)\n[0, 0, 2, 2, 4, 5, 5, 7, 7, 9, 9, 11, 12, 12, 14, 14]\n</code></pre>"},{"location":"patterns/warp/","title":"Warp","text":"<ul> <li>PWarp: Requests a new target warp value from <code>pattern</code> every <code>length</code> beats</li> <li>PWSine: Sinosoidal warp, period <code>length</code> beats, amplitude +/-. <li>PWRallantando: Exponential deceleration to  times the current tempo over <code>length</code> beats."},{"location":"patterns/warp/pwarp/","title":"Pattern: PWarp","text":"<p>Requests a new target warp value from <code>pattern</code> every <code>length</code> beats</p> <p>and applies linear interpolation to ramp between values. To select a new target warp value every 8 beats, between [-0.5, 0.5]:</p>"},{"location":"patterns/warp/pwarp/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PWInterpolate(PWhite(-0.5, 0.5), 8)\n</code></pre>"},{"location":"patterns/warp/pwrallantando/","title":"Pattern: PWRallantando","text":"<p>Exponential deceleration to  times the current tempo over <code>length</code> beats."},{"location":"patterns/warp/pwrallantando/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PWRallantando(8, 0.5)\n</code></pre>"},{"location":"patterns/warp/pwsine/","title":"Pattern: PWSine","text":"<p>Sinosoidal warp, period <code>length</code> beats, amplitude +/-."},{"location":"patterns/warp/pwsine/#example-output","title":"Example output","text":"<pre><code>&gt;&gt;&gt; p = PWAmp(8, 0.5)\n</code></pre>"},{"location":"timelines/","title":"Timelines","text":"<p>A <code>Timeline</code> schedules and executes events following a clock.</p> <p>By default, a Timeline creates its own internal clock at a specified tempo:</p> <pre><code>timeline = iso.Timeline(120)\ntimeline.run()\n</code></pre> <p>You can set and query the tempo using the <code>tempo</code> property:</p> <pre><code>&gt;&gt;&gt; timeline.tempo = 140\n&gt;&gt;&gt; print(timeline.tempo)\n140\n</code></pre>"},{"location":"timelines/#sync-from-clock-in","title":"Sync from clock in","text":"<p>A Timeline can be synchronised from an external MIDI clock:</p> <pre><code>midi_in = MidiInputDevice()\ntimeline = iso.Timeline(clock_source=midi_in)\ntimeline.run()\n</code></pre> <p>MIDI <code>start</code> and <code>stop</code> events will be followed. Querying the timeline's <code>tempo</code> will give an estimate of the current bpm based on a moving average.</p>"},{"location":"timelines/#sync-to-clock-out","title":"Sync to clock out","text":"<p>You can also drive external MIDI clocks from a Timeline, by specifying the <code>send_clock</code> argument when creating the output device.</p> <pre><code>output_device = iso.MidiOutputDevice(send_clock=True)\ntimeline = iso.Timeline(120, output_device=output_device)\ntimeline.run()\n</code></pre>"},{"location":"timelines/#scheduling-events","title":"Scheduling events","text":"<p>Scheduling events is done by passing a dict to the <code>Timeline.schedule()</code> method, which creates a new <code>Track</code> on the timeline. A timeline can have an unlimited number of tracks (unless you specify a limit with the <code>max_tracks</code> property).  </p> <pre><code>#--------------------------------------------------------------------------------\n# Play a series of 5 notes with random velocities.\n# Delay by 1 beat before playback.\n#--------------------------------------------------------------------------------\ntimeline = iso.Timeline(120)\ntimeline.schedule({\n    \"note\": iso.PSequence([ 60, 67, 72, 77, 84 ], 1),\n    \"duration\": 0.5,\n    \"amplitude\": iso.PWhite(0, 128)\n}, delay=1)\ntimeline.run()\n</code></pre> <p>Scheduling can be quantized or delayed by passing args to the <code>schedule()</code> method:</p> <ul> <li><code>quantize=N</code>: quantize to the next <code>N</code> beats before beginning playback. For example, <code>quantize=1</code> will quantize to the next beat. <code>quantize=0.25</code> will quantize to a quarter-beat.</li> <li><code>delay=N</code>: delay by <code>N</code> beats before beginning playback. If <code>quantize</code> and <code>delay</code> are both specified, quantization is applied, and the event is scheduled <code>delay</code> beats after the quantization time.</li> </ul> <p>To limit the number of iterations of an event, pass the <code>count</code> property:</p> <pre><code>timeline.schedule({\n    \"note\": iso.PSeries(0, 1) + 60\n}, count=4)\n</code></pre>"},{"location":"timelines/#clock-resolution-and-accuracy","title":"Clock resolution and accuracy","text":"<p>isobar's internal clock by default has a resolution of 480 ticks per beat (PPQN), which equates to a timing precision of 1ms at 120bpm.</p> <p>High-precision scheduling in Python is inherently limited by Python's global interpreter lock (GIL), which means that sub-millisecond accuracy is unfortunately not possible. The good news is that, when using Python 3+, jitter is pretty low: the unit test suite verifies that the host device is able to keep time to +/- 1ms, and passes on Linux and macOS. </p>"},{"location":"timelines/#nonlinear-time","title":"Nonlinear time","text":"<p>Time warping and nonlinear time is a work in progress.</p>"}]}